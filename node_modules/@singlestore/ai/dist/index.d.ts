import { ChatCompletionMessageParam } from 'openai/resources/chat/completions';
import z$1, { z } from 'zod';
import { OpenAI } from 'openai';
import { ChatCompletionCreateParamsBase } from 'openai/resources/chat/completions.mjs';
import { EmbeddingCreateParams } from 'openai/resources/embeddings';

interface ChatCompletion {
    content: string;
}
type ChatCompletionStream = AsyncGenerator<ChatCompletion>;
type OnChatCompletionChunk = (chunk: ChatCompletion) => Promise<void> | void;
interface ChatCompletionMessage {
    role: Extract<ChatCompletionMessageParam["role"], "system" | "assistant" | "user">;
    content: string | null;
}

type ChatCompletionToolCall<T extends string, U extends z.AnyZodObject | undefined, K> = (params: U extends z.AnyZodObject ? z.infer<U> : void) => Promise<{
    name: T;
    value: K;
    params?: U extends z.AnyZodObject ? z.infer<U> : undefined;
}>;
interface ChatCompletionToolConfig<T extends string, U extends z.AnyZodObject | undefined, K extends ChatCompletionToolCall<T, U, any>> {
    name: T;
    description: string;
    params?: U;
    call: K;
}
type AnyChatCompletionTool = ChatCompletionTool<string, z.AnyZodObject | undefined, ChatCompletionToolCall<string, any | undefined, any>>;
type MergeChatCompletionTools<T extends AnyChatCompletionTool[] | undefined, U extends AnyChatCompletionTool[] | undefined> = T extends AnyChatCompletionTool[] ? U extends AnyChatCompletionTool[] ? [...T, ...U] : T : U extends AnyChatCompletionTool[] ? U : undefined;
declare class ChatCompletionTool<T extends string, U extends z.AnyZodObject | undefined, K extends ChatCompletionToolCall<T, U, any>> {
    name: T;
    description: string;
    params: U;
    call: K;
    constructor(config: ChatCompletionToolConfig<T, U, K>);
}

interface CreateChatCompletionParams<TStream extends boolean | undefined, TChatCompletionTool extends AnyChatCompletionTool[] | undefined> {
    prompt?: string;
    model?: string;
    systemRole?: string;
    stream?: TStream;
    messages?: ChatCompletionMessage[];
    tools?: TChatCompletionTool;
    toolCallHandlers?: TChatCompletionTool extends AnyChatCompletionTool[] ? {
        [K in TChatCompletionTool[number] as K["name"]]?: (tool: K, params: K["params"] extends z$1.AnyZodObject ? z$1.infer<K["params"]> : undefined) => Promise<void>;
    } : undefined;
    toolCallResultHandlers?: TChatCompletionTool extends AnyChatCompletionTool[] ? {
        [K in TChatCompletionTool[number] as K["name"]]?: (tool: K, result: Awaited<ReturnType<K["call"]>>, params: K["params"] extends z$1.AnyZodObject ? z$1.infer<K["params"]> : undefined) => Promise<void>;
    } : undefined;
}
type CreateChatCompletionResult<TStream extends boolean | undefined> = TStream extends true ? ChatCompletionStream : ChatCompletion;
declare abstract class ChatCompletionsManager<TChatCompletionTool extends AnyChatCompletionTool[] | undefined> {
    tools: TChatCompletionTool;
    initTools(tools: TChatCompletionTool): void;
    abstract getModels(): Promise<string[]> | string[];
    handleStream(stream: ChatCompletionStream, onChunk?: OnChatCompletionChunk): Promise<ChatCompletion>;
    abstract create(params: CreateChatCompletionParams<any, any>): Promise<CreateChatCompletionResult<any>>;
}

type OpenAIChatCompletionModel = ChatCompletionCreateParamsBase["model"];
interface _OpenAICreateChatCompletionParams extends Omit<Partial<ChatCompletionCreateParamsBase>, keyof CreateChatCompletionParams<any, any>> {
}
interface OpenAICreateChatCompletionParams<TStream extends boolean | undefined, TChatCompletionTool extends AnyChatCompletionTool[] | undefined> extends CreateChatCompletionParams<TStream, TChatCompletionTool>, _OpenAICreateChatCompletionParams {
    model?: OpenAIChatCompletionModel;
}
declare class OpenAIChatCompletions<TChatCompletionTool extends AnyChatCompletionTool[] | undefined> extends ChatCompletionsManager<TChatCompletionTool> {
    private _openai;
    constructor(_openai: OpenAI);
    getModels(): OpenAIChatCompletionModel[];
    create<TStream extends boolean | undefined = false, TChatCompletionTool extends AnyChatCompletionTool[] | undefined = undefined>({ prompt, systemRole, messages, tools, toolCallHandlers, toolCallResultHandlers, ...params }: OpenAICreateChatCompletionParams<TStream, MergeChatCompletionTools<TChatCompletionTool, TChatCompletionTool>>): Promise<CreateChatCompletionResult<TStream>>;
}

declare function parseLengthErrorMessage(message: Error["message"]): [length: number | undefined, maxLength: number | undefined];

declare class MessageLengthExceededError extends Error {
    message: string;
    length?: number;
    maxLength?: number;
    cause?: unknown;
    constructor(message: string, options?: {
        length?: number;
        maxLength?: number;
        cause?: unknown;
    });
}

declare class MessagesLengthExceededError extends Error {
    message: string;
    length?: number;
    maxLength?: number;
    cause?: unknown;
    constructor(message: string, options?: {
        length?: number;
        maxLength?: number;
        cause?: unknown;
    });
}

type Embedding = number[];

interface CreateEmbeddingsParams {
    model?: string;
}
declare abstract class EmbeddingsManager {
    abstract getModels(): string[];
    abstract create(input: string | string[], params?: CreateEmbeddingsParams): Promise<Embedding[]>;
}

type _OpenAICreateEmbeddingsParams = Omit<Partial<EmbeddingCreateParams>, "input" | keyof CreateEmbeddingsParams>;
type OpenAIEmbeddingModel = EmbeddingCreateParams["model"];
interface OpenAICreateEmbeddingsParams extends CreateEmbeddingsParams, _OpenAICreateEmbeddingsParams {
    model?: OpenAIEmbeddingModel;
}
declare class OpenAIEmbeddingsManager extends EmbeddingsManager {
    private _openai;
    constructor(_openai: OpenAI);
    getModels(): OpenAIEmbeddingModel[];
    create(input: string | string[], params?: OpenAICreateEmbeddingsParams): Promise<Embedding[]>;
}

interface TextSplitterSplitOptions {
    chunkSize?: number;
    delimiter?: string;
}
declare class TextSplitter {
    split(text: string, options?: TextSplitterSplitOptions): string[];
}

interface AIConfig<TChatCompletionTools extends AnyChatCompletionTool[] | undefined, TChatCompletionsManager extends ChatCompletionsManager<TChatCompletionTools>, TEmbeddingsManager extends EmbeddingsManager, TTextSplitter extends TextSplitter> {
    openAIApiKey?: string;
    chatCompletionTools?: TChatCompletionTools;
    chatCompletionsManager?: TChatCompletionsManager;
    embeddingsManager?: TEmbeddingsManager;
    textSplitter?: TTextSplitter;
}
type AnyAI = AI<AnyChatCompletionTool[] | undefined, ChatCompletionsManager<any>, EmbeddingsManager, TextSplitter>;
declare class AI<TChatCompletionTools extends AnyChatCompletionTool[] | undefined = undefined, TChatCompletions extends ChatCompletionsManager<any> = OpenAIChatCompletions<TChatCompletionTools>, TEmbeddingsManager extends EmbeddingsManager = OpenAIEmbeddingsManager, TTextSplitter extends TextSplitter = TextSplitter> {
    embeddings: TEmbeddingsManager;
    chatCompletions: TChatCompletions;
    textSplitter: TTextSplitter;
    constructor(config: AIConfig<TChatCompletionTools, TChatCompletions, TEmbeddingsManager, TTextSplitter>);
}

export { AI, type AIConfig, type AnyAI, type AnyChatCompletionTool, type ChatCompletion, type ChatCompletionMessage, type ChatCompletionStream, ChatCompletionTool, type ChatCompletionToolCall, ChatCompletionsManager, type CreateChatCompletionParams, type CreateChatCompletionResult, type CreateEmbeddingsParams, type Embedding, EmbeddingsManager, type MergeChatCompletionTools, MessageLengthExceededError, MessagesLengthExceededError, type OnChatCompletionChunk, type OpenAIChatCompletionModel, OpenAIChatCompletions, type OpenAICreateChatCompletionParams, type OpenAICreateEmbeddingsParams, type OpenAIEmbeddingModel, OpenAIEmbeddingsManager, TextSplitter, type TextSplitterSplitOptions, parseLengthErrorMessage };
