{"version":3,"sources":["../src/index.ts","../src/chat-completions/manager.ts","../src/chat-completions/openai.ts","../src/chat-completions/errors/lib/parse-length-error-message.ts","../src/chat-completions/errors/message-length-exceeded.ts.ts","../src/chat-completions/errors/messages-length-exceeded.ts","../src/chat-completions/tool.ts","../src/embeddings/manager.ts","../src/embeddings/openai.ts","../src/text-splitter/text-splitter.ts","../src/ai.ts"],"sourcesContent":["export type * from \"./types\";\nexport { ChatCompletionsManager, ChatCompletionTool } from \"./chat-completions\";\nexport { EmbeddingsManager } from \"./embeddings\";\nexport { MessageLengthExceededError, MessagesLengthExceededError, parseLengthErrorMessage } from \"./chat-completions/errors\";\nexport { TextSplitter } from \"./text-splitter\";\nexport * from \"./ai\";\n","import z from \"zod\";\n\nimport type { ChatCompletion, ChatCompletionMessage, ChatCompletionStream, OnChatCompletionChunk } from \"./chat-completion\";\nimport type { AnyChatCompletionTool } from \"./tool\";\n\nexport interface CreateChatCompletionParams<\n  TStream extends boolean | undefined,\n  TChatCompletionTool extends AnyChatCompletionTool[] | undefined,\n> {\n  prompt?: string;\n  model?: string;\n  systemRole?: string;\n  stream?: TStream;\n  messages?: ChatCompletionMessage[];\n  tools?: TChatCompletionTool;\n\n  toolCallHandlers?: TChatCompletionTool extends AnyChatCompletionTool[]\n    ? {\n        [K in TChatCompletionTool[number] as K[\"name\"]]?: (\n          tool: K,\n          params: K[\"params\"] extends z.AnyZodObject ? z.infer<K[\"params\"]> : undefined,\n        ) => Promise<void>;\n      }\n    : undefined;\n\n  toolCallResultHandlers?: TChatCompletionTool extends AnyChatCompletionTool[]\n    ? {\n        [K in TChatCompletionTool[number] as K[\"name\"]]?: (\n          tool: K,\n          result: Awaited<ReturnType<K[\"call\"]>>,\n          params: K[\"params\"] extends z.AnyZodObject ? z.infer<K[\"params\"]> : undefined,\n        ) => Promise<void>;\n      }\n    : undefined;\n}\n\nexport type CreateChatCompletionResult<TStream extends boolean | undefined> = TStream extends true\n  ? ChatCompletionStream\n  : ChatCompletion;\n\nexport abstract class ChatCompletionsManager<TChatCompletionTool extends AnyChatCompletionTool[] | undefined> {\n  tools = undefined as TChatCompletionTool;\n\n  initTools(tools: TChatCompletionTool) {\n    this.tools = tools;\n  }\n\n  abstract getModels(): Promise<string[]> | string[];\n\n  async handleStream(stream: ChatCompletionStream, onChunk?: OnChatCompletionChunk): Promise<ChatCompletion> {\n    let completion: ChatCompletion = { content: \"\" };\n\n    for await (const chunk of stream) {\n      completion = { ...completion, ...chunk, content: `${completion.content}${chunk.content}` };\n      await onChunk?.(chunk);\n    }\n\n    return completion;\n  }\n\n  abstract create(params: CreateChatCompletionParams<any, any>): Promise<CreateChatCompletionResult<any>>;\n}\n","import { BadRequestError, type OpenAI } from \"openai\";\nimport zodToJsonSchema from \"zod-to-json-schema\";\n\nimport type { ChatCompletionMessage, ChatCompletionStream } from \"./chat-completion\";\nimport type {\n  ChatCompletionChunk,\n  ChatCompletionCreateParamsBase,\n  ChatCompletionMessageParam,\n  ChatCompletionMessageToolCall,\n  ChatCompletionToolMessageParam,\n} from \"openai/resources/chat/completions.mjs\";\nimport type { Stream } from \"openai/streaming.mjs\";\n\nimport { MessageLengthExceededError, MessagesLengthExceededError, parseLengthErrorMessage } from \"./errors\";\nimport { ChatCompletionsManager, type CreateChatCompletionParams, type CreateChatCompletionResult } from \"./manager\";\nimport { type AnyChatCompletionTool, type MergeChatCompletionTools } from \"./tool\";\n\nexport type OpenAIChatCompletionModel = ChatCompletionCreateParamsBase[\"model\"];\n\ninterface _OpenAICreateChatCompletionParams\n  extends Omit<Partial<ChatCompletionCreateParamsBase>, keyof CreateChatCompletionParams<any, any>> {}\n\nexport interface OpenAICreateChatCompletionParams<\n  TStream extends boolean | undefined,\n  TChatCompletionTool extends AnyChatCompletionTool[] | undefined,\n> extends CreateChatCompletionParams<TStream, TChatCompletionTool>,\n    _OpenAICreateChatCompletionParams {\n  model?: OpenAIChatCompletionModel;\n}\n\nexport class OpenAIChatCompletions<\n  TChatCompletionTool extends AnyChatCompletionTool[] | undefined,\n> extends ChatCompletionsManager<TChatCompletionTool> {\n  constructor(private _openai: OpenAI) {\n    super();\n  }\n\n  getModels(): OpenAIChatCompletionModel[] {\n    // TODO: Replace with dynamic values\n    return [\n      \"gpt-4o\",\n      \"gpt-4o-2024-05-13\",\n      \"gpt-4o-2024-08-06\",\n      \"gpt-4o-mini\",\n      \"gpt-4o-mini-2024-07-18\",\n      \"gpt-4-turbo\",\n      \"gpt-4-turbo-2024-04-09\",\n      \"gpt-4-turbo-preview\",\n      \"gpt-4-0125-preview\",\n      \"gpt-4-1106-preview\",\n      \"gpt-4\",\n      \"gpt-4-0613\",\n      \"gpt-3.5-turbo-0125\",\n      \"gpt-3.5-turbo\",\n      \"gpt-3.5-turbo-1106\",\n      \"gpt-3.5-turbo-instruct\",\n    ];\n  }\n\n  async create<\n    TStream extends boolean | undefined = false,\n    TChatCompletionTool extends AnyChatCompletionTool[] | undefined = undefined,\n  >({\n    prompt,\n    systemRole,\n    messages,\n    tools,\n    toolCallHandlers,\n    toolCallResultHandlers,\n    ...params\n  }: OpenAICreateChatCompletionParams<TStream, MergeChatCompletionTools<TChatCompletionTool, TChatCompletionTool>>): Promise<\n    CreateChatCompletionResult<TStream>\n  > {\n    let _messages: ChatCompletionMessage[] = [];\n    if (systemRole) _messages.push({ role: \"system\", content: systemRole });\n    if (messages?.length) _messages = [..._messages, ...messages];\n    if (prompt) _messages.push({ role: \"user\", content: prompt });\n\n    let _tools: AnyChatCompletionTool[] = [];\n    if (this.tools?.length) _tools = [..._tools, ...this.tools];\n    if (tools?.length) _tools = [..._tools, ...tools];\n\n    let response;\n\n    try {\n      response = await this._openai.chat.completions.create({\n        model: \"gpt-4o-mini\",\n        temperature: 0,\n        ...params,\n        messages: _messages as ChatCompletionMessageParam[],\n        tools: _tools.length\n          ? _tools.map(({ name, description, params }) => ({\n              type: \"function\",\n              function: { name, description, parameters: params ? zodToJsonSchema(params) : undefined },\n            }))\n          : undefined,\n      });\n    } catch (error) {\n      if (error instanceof BadRequestError) {\n        if (error.code === \"array_above_max_length\") {\n          const [length, maxLength] = parseLengthErrorMessage(error.message);\n          throw new MessagesLengthExceededError(error.message, { length, maxLength, cause: error });\n        }\n\n        if (error.code === \"string_above_max_length\") {\n          const [length, maxLength] = parseLengthErrorMessage(error.message);\n          throw new MessageLengthExceededError(error.message, { length, maxLength, cause: error });\n        }\n      }\n\n      throw error;\n    }\n\n    const handleToolCalls = (\n      toolCalls: ChatCompletionMessageToolCall[] | ChatCompletionChunk[\"choices\"][number][\"delta\"][\"tool_calls\"] = [],\n    ) => {\n      type ToolCall = (typeof _tools)[number][\"call\"];\n\n      return Promise.all(\n        toolCalls.map(async (call) => {\n          const _call = { ...call, id: call.id || \"\" };\n\n          if (!call.function) {\n            throw new Error(`Invalid tool call: ${JSON.stringify(call)}`);\n          }\n\n          let params: Parameters<ToolCall>[0];\n          if (call.function.arguments) {\n            try {\n              params = JSON.parse(call.function.arguments);\n            } catch (error) {\n              throw new Error(`Invalid parameters provided for the \"${call.function.name}\" tool.`, { cause: error });\n            }\n          }\n\n          const tool = _tools.find(({ name }) => name === call.function?.name);\n          if (!tool) {\n            throw new Error(`The \"${call.function.name}\" tool is undefined.`);\n          }\n\n          try {\n            await toolCallHandlers?.[tool.name]?.(tool, params);\n            const result = await tool.call(params);\n            await toolCallResultHandlers?.[tool.name]?.(tool, result, params);\n            return [{ tool, params, value: result.value }, _call] as const;\n          } catch (error) {\n            let _error = error;\n\n            if (typeof error !== \"string\") {\n              if (error instanceof Error) {\n                _error = `Error: ${error.message}`;\n              } else {\n                try {\n                  _error = JSON.stringify(error, Object.getOwnPropertyNames(error));\n                } catch (error) {\n                  _error = JSON.stringify(error, Object.getOwnPropertyNames(error));\n                }\n              }\n            }\n\n            return [{ tool, params, error: _error }, _call] as const;\n          }\n        }),\n      );\n    };\n\n    const handleToolCallResults = (\n      results: Awaited<ReturnType<typeof handleToolCalls>>,\n      message?: ChatCompletionMessageParam | ChatCompletionChunk[\"choices\"][number][\"delta\"],\n    ) => {\n      return this.create({\n        ...params,\n        tools,\n        messages: [\n          ..._messages,\n          message,\n          ...results.map(([result, { id }]) => {\n            return {\n              role: \"tool\",\n              tool_call_id: id,\n              content: \"error\" in result ? result.error : result.value,\n            } satisfies ChatCompletionToolMessageParam;\n          }),\n        ] as ChatCompletionMessage[],\n      });\n    };\n\n    if (typeof response === \"object\" && response && \"choices\" in response) {\n      const message = response.choices[0]?.message;\n\n      if (message && \"tool_calls\" in message && message.tool_calls?.length) {\n        const toolCallResults = await handleToolCalls(message.tool_calls);\n        return (await handleToolCallResults(toolCallResults, message)) as CreateChatCompletionResult<TStream>;\n      }\n\n      return { content: message?.content || \"\" } as CreateChatCompletionResult<TStream>;\n    }\n\n    async function* handleStream(stream: Stream<ChatCompletionChunk>): ChatCompletionStream {\n      let delta: ChatCompletionChunk[\"choices\"][number][\"delta\"] | undefined = undefined;\n\n      for await (const chunk of stream) {\n        const _delta = chunk.choices[0]?.delta;\n        if (!delta) delta = { ..._delta, content: _delta?.content || \"\", tool_calls: [] };\n\n        if (_delta && \"tool_calls\" in _delta && _delta.tool_calls?.length) {\n          for (const toolCall of _delta.tool_calls) {\n            if (!delta || !delta.tool_calls) break;\n            const deltaToolCall = delta.tool_calls[toolCall.index] || { function: { arguments: \"\" } };\n            delta.tool_calls[toolCall.index] = {\n              ...deltaToolCall,\n              ...toolCall,\n              function: {\n                ...deltaToolCall.function,\n                ...toolCall.function,\n                arguments: `${deltaToolCall.function?.arguments || \"\"}${toolCall.function?.arguments || \"\"}`,\n              },\n            };\n          }\n        } else {\n          yield { content: _delta?.content || \"\" };\n        }\n      }\n\n      if (delta?.tool_calls?.length) {\n        const toolCallResults = await handleToolCalls(delta.tool_calls);\n        const toolCallResultsStream = (await handleToolCallResults(toolCallResults, delta)) as ChatCompletionStream;\n        for await (const chunk of toolCallResultsStream) yield chunk;\n      }\n    }\n\n    return handleStream(response) as CreateChatCompletionResult<TStream>;\n  }\n}\n","export function parseLengthErrorMessage(\n  message: Error[\"message\"],\n): [length: number | undefined, maxLength: number | undefined] {\n  const [maxLength, length] = [...message.matchAll(/length\\s+(\\d+)/g)].map((match) => Number(match[1]));\n  return [length, maxLength];\n}\n","export class MessageLengthExceededError extends Error {\n  length?: number;\n  maxLength?: number;\n  cause?: unknown;\n\n  constructor(\n    public message: string,\n    options?: { length?: number; maxLength?: number; cause?: unknown },\n  ) {\n    super(message, { cause: options?.cause });\n\n    this.name = \"MessageLengthExceededError\";\n    this.length = options?.length;\n    this.maxLength = options?.maxLength;\n  }\n}\n","export class MessagesLengthExceededError extends Error {\n  length?: number;\n  maxLength?: number;\n  cause?: unknown;\n\n  constructor(\n    public message: string,\n    options?: { length?: number; maxLength?: number; cause?: unknown },\n  ) {\n    super(message, { cause: options?.cause });\n\n    this.name = \"MessagesLengthExceededError\";\n    this.length = options?.length;\n    this.maxLength = options?.maxLength;\n  }\n}\n","import { z } from \"zod\";\n\nexport type ChatCompletionToolCall<T extends string, U extends z.AnyZodObject | undefined, K> = (\n  params: U extends z.AnyZodObject ? z.infer<U> : void,\n) => Promise<{ name: T; value: K; params?: U extends z.AnyZodObject ? z.infer<U> : undefined }>;\n\ninterface ChatCompletionToolConfig<\n  T extends string,\n  U extends z.AnyZodObject | undefined,\n  K extends ChatCompletionToolCall<T, U, any>,\n> {\n  name: T;\n  description: string;\n  params?: U;\n  call: K;\n}\n\nexport type AnyChatCompletionTool = ChatCompletionTool<\n  string,\n  z.AnyZodObject | undefined,\n  ChatCompletionToolCall<string, any | undefined, any>\n>;\n\nexport type MergeChatCompletionTools<\n  T extends AnyChatCompletionTool[] | undefined,\n  U extends AnyChatCompletionTool[] | undefined,\n> = T extends AnyChatCompletionTool[]\n  ? U extends AnyChatCompletionTool[]\n    ? [...T, ...U]\n    : T\n  : U extends AnyChatCompletionTool[]\n    ? U\n    : undefined;\n\nexport class ChatCompletionTool<\n  T extends string,\n  U extends z.AnyZodObject | undefined,\n  K extends ChatCompletionToolCall<T, U, any>,\n> {\n  name: T;\n  description: string;\n  params: U;\n  call: K;\n\n  constructor(config: ChatCompletionToolConfig<T, U, K>) {\n    this.name = config.name;\n    this.description = config.description;\n    this.params = config.params as U;\n    this.call = config.call;\n  }\n}\n","import type { Embedding } from \"./embedding\";\n\nexport interface CreateEmbeddingsParams {\n  model?: string;\n}\n\nexport abstract class EmbeddingsManager {\n  abstract getModels(): string[];\n\n  abstract create(input: string | string[], params?: CreateEmbeddingsParams): Promise<Embedding[]>;\n}\n","import type { Embedding } from \"./embedding\";\nimport type { OpenAI } from \"openai\";\nimport type { EmbeddingCreateParams } from \"openai/resources/embeddings\";\n\nimport { type CreateEmbeddingsParams, EmbeddingsManager } from \"./manager\";\n\ntype _OpenAICreateEmbeddingsParams = Omit<Partial<EmbeddingCreateParams>, \"input\" | keyof CreateEmbeddingsParams>;\n\nexport type OpenAIEmbeddingModel = EmbeddingCreateParams[\"model\"];\n\nexport interface OpenAICreateEmbeddingsParams extends CreateEmbeddingsParams, _OpenAICreateEmbeddingsParams {\n  model?: OpenAIEmbeddingModel;\n}\n\nexport class OpenAIEmbeddingsManager extends EmbeddingsManager {\n  constructor(private _openai: OpenAI) {\n    super();\n  }\n\n  getModels(): OpenAIEmbeddingModel[] {\n    // TODO: Replace with dynamic values\n    return [\"text-embedding-3-small\", \"text-embedding-3-large\", \"text-embedding-ada-002\"];\n  }\n\n  async create(input: string | string[], params?: OpenAICreateEmbeddingsParams): Promise<Embedding[]> {\n    const _input = Array.isArray(input) ? input : [input];\n    const response = await this._openai.embeddings.create({ model: \"text-embedding-3-small\", ...params, input: _input });\n    return response.data.map((data) => data.embedding);\n  }\n}\n","export interface TextSplitterSplitOptions {\n  chunkSize?: number;\n  delimiter?: string;\n}\n\nexport class TextSplitter {\n  split(text: string, options: TextSplitterSplitOptions = {}): string[] {\n    const { chunkSize = 1024, delimiter = /(?<=[.!?])[\\s\\n]+/ } = options;\n\n    const chunks: string[] = [];\n    let accChunk: string[] = [];\n    let accChunkLength = 0;\n\n    for (const chunk of text.split(delimiter)) {\n      if (chunk.length > chunkSize) {\n        let subChunks: string[] = [];\n\n        if (delimiter === \" \") {\n          subChunks.push(chunk);\n        } else {\n          subChunks = this.split(chunk, { chunkSize, delimiter: \" \" });\n        }\n\n        if (accChunkLength > 0) {\n          chunks.push(accChunk.join(\" \"));\n          accChunk = [];\n          accChunkLength = 0;\n        }\n\n        chunks.push(...subChunks);\n      } else if (accChunkLength + chunk.length <= chunkSize) {\n        accChunk.push(chunk);\n        accChunkLength += chunk.length;\n      } else {\n        chunks.push(accChunk.join(\" \"));\n        accChunk = [chunk];\n        accChunkLength = chunk.length;\n      }\n    }\n\n    if (accChunk.length > 0) {\n      chunks.push(accChunk.join(\" \"));\n    }\n\n    return chunks;\n  }\n}\n","import OpenAI from \"openai\";\n\nimport { type AnyChatCompletionTool, type ChatCompletionsManager, OpenAIChatCompletions } from \"./chat-completions\";\nimport { type EmbeddingsManager, OpenAIEmbeddingsManager } from \"./embeddings\";\nimport { TextSplitter } from \"./text-splitter\";\n\nexport interface AIConfig<\n  TChatCompletionTools extends AnyChatCompletionTool[] | undefined,\n  TChatCompletionsManager extends ChatCompletionsManager<TChatCompletionTools>,\n  TEmbeddingsManager extends EmbeddingsManager,\n  TTextSplitter extends TextSplitter,\n> {\n  openAIApiKey?: string;\n  chatCompletionTools?: TChatCompletionTools;\n  chatCompletionsManager?: TChatCompletionsManager;\n  embeddingsManager?: TEmbeddingsManager;\n  textSplitter?: TTextSplitter;\n}\n\nexport type AnyAI = AI<AnyChatCompletionTool[] | undefined, ChatCompletionsManager<any>, EmbeddingsManager, TextSplitter>;\n\nexport class AI<\n  TChatCompletionTools extends AnyChatCompletionTool[] | undefined = undefined,\n  TChatCompletions extends ChatCompletionsManager<any> = OpenAIChatCompletions<TChatCompletionTools>,\n  TEmbeddingsManager extends EmbeddingsManager = OpenAIEmbeddingsManager,\n  TTextSplitter extends TextSplitter = TextSplitter,\n> {\n  embeddings: TEmbeddingsManager;\n  chatCompletions: TChatCompletions;\n  textSplitter: TTextSplitter;\n\n  constructor(config: AIConfig<TChatCompletionTools, TChatCompletions, TEmbeddingsManager, TTextSplitter>) {\n    const openai = new OpenAI({ apiKey: config.openAIApiKey });\n\n    this.chatCompletions = (config.chatCompletionsManager ?? new OpenAIChatCompletions(openai)) as TChatCompletions;\n    this.embeddings = (config.embeddingsManager ?? new OpenAIEmbeddingsManager(openai)) as TEmbeddingsManager;\n    this.textSplitter = (config.textSplitter ?? new TextSplitter()) as TTextSplitter;\n\n    if (config.chatCompletionTools?.length) {\n      this.chatCompletions.initTools(config.chatCompletionTools);\n    }\n  }\n}\n"],"mappings":"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","names":["params","zodToJsonSchema","error","import_openai","OpenAI"]}