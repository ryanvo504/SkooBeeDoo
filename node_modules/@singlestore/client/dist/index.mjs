// src/index.ts
import { escape as escape2 } from "mysql2";

// src/api/api.ts
var API = class {
  constructor(_apiKey, _version = 1) {
    this._apiKey = _apiKey;
    this._version = _version;
    this._baseURL = `https://api.singlestore.com`;
  }
  _baseURL;
  async execute(url, { version = this._version, ...params } = {}) {
    if (!this._apiKey) {
      throw new Error(
        "The Management API key is undefined. Please generate a valid API key. For more info read: https://docs.singlestore.com/cloud/reference/management-api/#generate-an-api-key"
      );
    }
    const _url = `${this._baseURL}/v${version}${url}`;
    const response = await fetch(_url, {
      method: "GET",
      ...params,
      headers: {
        "Content-Type": "application/json",
        ...params?.headers,
        "Authorization": `Bearer ${this._apiKey}`
      }
    });
    const contentType = response.headers.get("content-type");
    if (contentType?.startsWith("text/plain")) {
      return response.text();
    }
    return response.json();
  }
};

// src/api/manager.ts
var APIManager = class {
  constructor(_api) {
    this._api = _api;
  }
  _execute(...[url, params]) {
    return this._api.execute(`${this._baseURL}${url ?? ""}`, params);
  }
};

// src/billing/manager.ts
var BillingManager = class extends APIManager {
  _baseURL = "/billing";
  async get({ metric, startTime, endTime, aggregateBy }) {
    const params = new URLSearchParams({ metric });
    Object.entries({ startTime, endTime }).forEach(([key, value]) => {
      params.set(key, value.toISOString().split(".")[0] + "Z");
    });
    if (aggregateBy) {
      params.set("aggregateBy", aggregateBy);
    }
    const response = await this._execute(`/usage?${params.toString()}`);
    return response.billingUsage.map((data) => {
      const usage = data.Usage.map((usage2) => {
        return {
          ...usage2,
          startTime: new Date(startTime),
          endTime: new Date(endTime)
        };
      });
      if (metric === "ComputeCredit") {
        return {
          metric: "ComputeCredit",
          description: data.description,
          usage
        };
      }
      return {
        metric: "StorageAvgByte",
        description: data.description,
        usage
      };
    });
  }
};

// src/job/job.ts
var Job = class _Job extends APIManager {
  constructor(_api, id, name, description, enqueuedBy, executionConfig, metadata, targetConfig, completedExecutionsCount, schedule, createdAt, terminatedAt) {
    super(_api);
    this.id = id;
    this.name = name;
    this.description = description;
    this.enqueuedBy = enqueuedBy;
    this.executionConfig = executionConfig;
    this.metadata = metadata;
    this.targetConfig = targetConfig;
    this.completedExecutionsCount = completedExecutionsCount;
    this.schedule = schedule;
    this.createdAt = createdAt;
    this.terminatedAt = terminatedAt;
    this._baseURL = _Job.getBaseURL(this.id);
  }
  _baseURL;
  static getBaseURL(id) {
    return `/jobs/${id}`;
  }
  static async delete(api, id) {
    return api.execute(this.getBaseURL(id), { method: "DELETE" });
  }
  static async getExecutions(api, id, start, end) {
    const params = new URLSearchParams({ start: start.toString(), end: end.toString() });
    const response = await api.execute(`${this.getBaseURL(id)}/executions?${params.toString()}`);
    return response.executions.map((execution) => {
      return {
        id: execution.executionID,
        number: execution.executionNumber,
        jobID: execution.jobID,
        scheduledStartTime: new Date(execution.scheduledStartTime),
        startedAt: new Date(execution.startedAt),
        finishedAt: new Date(execution.finishedAt),
        snapshotNotebookPath: execution.snapshotNotebookPath,
        status: execution.status
      };
    });
  }
  static async getParameters(api, id) {
    return api.execute(`${this.getBaseURL(id)}/parameters`);
  }
  async delete() {
    return _Job.delete(this._api, this.id);
  }
  async getExecutions(start, end) {
    return _Job.getExecutions(this._api, this.id, start, end);
  }
  async getParameters() {
    return _Job.getParameters(this._api, this.id);
  }
};

// src/job/manager.ts
var JobManager = class extends APIManager {
  _baseURL = "/jobs";
  _create(data) {
    return new Job(
      this._api,
      data.jobID,
      data.name,
      data.description,
      data.enqueuedBy,
      data.executionConfig,
      data.jobMetadata,
      data.targetConfig,
      data.completedExecutionsCount,
      { ...data.schedule, startAt: data.schedule.startAt ? new Date(data.schedule.startAt) : null },
      new Date(data.createdAt),
      data.terminatedAt ? new Date(data.terminatedAt) : null
    );
  }
  async create(body) {
    const response = await this._execute("", { method: "POST", body: JSON.stringify(body) });
    return this._create(response);
  }
  async get(id) {
    const response = await this._execute(`/${id}`);
    return this._create(response);
  }
  async delete(...args) {
    return Job.delete(this._api, ...args);
  }
  async getExecutions(...args) {
    return Job.getExecutions(this._api, ...args);
  }
  async getParameters(...args) {
    return Job.getParameters(this._api, ...args);
  }
  async getRuntimes() {
    return this._execute("/runtimes");
  }
};

// src/organization/manager.ts
var OrganizationManager = class extends APIManager {
  _baseURL = "/organizations";
  async get() {
    const respnose = await this._execute("/current");
    return {
      id: respnose.orgID,
      name: respnose.name
    };
  }
};

// src/region/manager.ts
var RegionManager = class extends APIManager {
  _baseURL = "/regions";
  async get(where) {
    const response = await this._execute();
    if (where && ("id" in where || "name" in where)) {
      const region = response.find((region2) => {
        if ("id" in where) return region2.regionID === where.id;
        if ("name" in where) return region2.region === where.name;
        return false;
      });
      if (!region) return void 0;
      return {
        id: region.regionID,
        name: region.region,
        provider: region.provider
      };
    }
    return response.map((data) => ({
      id: data.regionID,
      name: data.region,
      provider: data.provider
    }));
  }
};

// src/secret/secret.ts
var Secret = class _Secret extends APIManager {
  constructor(api, id, name, value, lastUpdatedBy, lastUpdatedAt, createdBy, createdAt) {
    super(api);
    this.id = id;
    this.name = name;
    this.value = value;
    this.lastUpdatedBy = lastUpdatedBy;
    this.lastUpdatedAt = lastUpdatedAt;
    this.createdBy = createdBy;
    this.createdAt = createdAt;
    this._baseURL = _Secret.getBaseURL(this.id);
  }
  _baseURL;
  static getBaseURL(id) {
    return `/secrets/${id}`;
  }
  static async update(api, id, value) {
    const response = await api.execute(this.getBaseURL(id), {
      method: "PATCH",
      body: JSON.stringify({ value })
    });
    return new _Secret(
      api,
      response.secretID,
      response.name,
      response.value,
      response.lastUpdatedBy,
      new Date(response.lastUpdatedAt),
      response.createdBy,
      new Date(response.createdAt)
    );
  }
  static async delete(api, id) {
    const response = await api.execute(this.getBaseURL(id), { method: "DELETE" });
    return response.secretID;
  }
  async update(value) {
    return _Secret.update(this._api, this.id, value);
  }
  async delete() {
    return _Secret.delete(this._api, this.id);
  }
};

// src/secret/manager.ts
var SecretManager = class extends APIManager {
  _baseURL = "/secrets";
  _create(data) {
    return new Secret(
      this._api,
      data.secretID,
      data.name,
      data.value,
      data.lastUpdatedBy,
      new Date(data.lastUpdatedAt),
      data.createdBy,
      new Date(data.createdAt)
    );
  }
  async create(body) {
    const response = await this._execute("", {
      method: "POST",
      body: JSON.stringify(body)
    });
    return this._create(response.secret);
  }
  async get(where) {
    let url = "";
    const params = new URLSearchParams();
    if (where) {
      if ("name" in where) {
        params.set("name", where.name);
      } else if ("id" in where) {
        url = `${url}/${where.id}`;
      }
    }
    const response = await this._execute(`${url}?${params.toString()}`);
    if ("secrets" in response) {
      if (!where) {
        return response.secrets.map((data) => this._create(data));
      }
      if (response.secrets[0]) {
        return this._create(response.secrets[0]);
      }
    }
    if ("secret" in response && response.secret) {
      return this._create(response.secret);
    }
    return [];
  }
  async update(...args) {
    return Secret.update(this._api, ...args);
  }
  async delete(...args) {
    return Secret.delete(this._api, ...args);
  }
};

// src/team/team.ts
var Team = class _Team extends APIManager {
  constructor(api, id, name, description, memberTeams, memberUsers, createdAt) {
    super(api);
    this.id = id;
    this.name = name;
    this.description = description;
    this.memberTeams = memberTeams;
    this.memberUsers = memberUsers;
    this.createdAt = createdAt;
    this._baseURL = _Team.getBaseURL(this.id);
  }
  _baseURL;
  static getBaseURL(id) {
    return `/teams/${id}`;
  }
  static async update(api, id, body) {
    const response = await api.execute(this.getBaseURL(id), {
      method: "PATCH",
      body: JSON.stringify(body)
    });
    return response.teamID;
  }
  static async delete(api, id) {
    const response = await api.execute(this.getBaseURL(id), { method: "DELETE" });
    return response.teamID;
  }
  static async addMemberTeams(api, id, teamIDs) {
    const response = await api.execute(this.getBaseURL(id), {
      method: "PATCH",
      body: JSON.stringify({ addMemberTeamIDs: teamIDs })
    });
    return response.teamID;
  }
  static async removeMemberTeams(api, id, teamIDs) {
    const response = await api.execute(this.getBaseURL(id), {
      method: "PATCH",
      body: JSON.stringify({ removeMemberTeamIDs: teamIDs })
    });
    return response.teamID;
  }
  static async addMemberUsers(api, id, userIDs) {
    const response = await api.execute(this.getBaseURL(id), {
      method: "PATCH",
      body: JSON.stringify({ addMemberUserIDs: userIDs })
    });
    return response.teamID;
  }
  static async removeMemberUsers(api, id, userIDs) {
    const response = await api.execute(this.getBaseURL(id), {
      method: "PATCH",
      body: JSON.stringify({ removeMemberUserIDs: userIDs })
    });
    return response.teamID;
  }
  async update(body) {
    return _Team.update(this._api, this.id, body);
  }
  async delete() {
    return _Team.delete(this._api, this.id);
  }
  async addMemberTeams(teamIDs) {
    return _Team.addMemberTeams(this._api, this.id, teamIDs);
  }
  async removeMemberTeams(teamIDs) {
    return _Team.removeMemberTeams(this._api, this.id, teamIDs);
  }
  async addMemberUsers(userIDs) {
    return _Team.addMemberUsers(this._api, this.id, userIDs);
  }
  async removeMemberUsers(userIDs) {
    return _Team.removeMemberUsers(this._api, this.id, userIDs);
  }
};

// src/team/manager.ts
var TeamManager = class extends APIManager {
  _baseURL = "/teams";
  _create(data) {
    return new Team(
      this._api,
      data.teamID,
      data.name,
      data.description,
      data.memberTeams?.map(({ teamID, ...team }) => ({ ...team, id: teamID })),
      data.memberUsers?.map(({ userID, ...user }) => ({ ...user, id: userID })),
      new Date(data.createdAt)
    );
  }
  async create({ memberTeams, memberUsers, ...body }) {
    let newTeam = await this._execute("", {
      method: "POST",
      body: JSON.stringify(body)
    });
    if (memberTeams?.length || memberUsers?.length) {
      await this._execute(`/${newTeam.teamID}`, {
        method: "PATCH",
        body: JSON.stringify({
          addMemberTeamIDs: memberTeams,
          addMemberUserIDs: memberUsers
        })
      });
      newTeam = await this._execute(`/${newTeam.teamID}`);
    }
    return this._create(newTeam);
  }
  async get(where) {
    let url = "";
    const params = new URLSearchParams();
    if (where) {
      if ("id" in where) {
        url = `${url}/${where.id}`;
      } else {
        params.set(...Object.entries(where)[0]);
      }
    }
    const response = await this._execute(`${url}?${params.toString()}`);
    if (Array.isArray(response)) {
      return response.map((data) => this._create(data));
    }
    return this._create(response);
  }
  async update(...args) {
    return Team.update(this._api, ...args);
  }
  async delete(...args) {
    return Team.delete(this._api, ...args);
  }
  async addMemberTeams(...args) {
    return Team.addMemberTeams(this._api, ...args);
  }
  async removeMemberTeams(...args) {
    return Team.removeMemberTeams(this._api, ...args);
  }
  async addMemberUsers(...args) {
    return Team.addMemberUsers(this._api, ...args);
  }
  async removeMemberUsers(...args) {
    return Team.removeMemberUsers(this._api, ...args);
  }
};

// src/connection.ts
import { createPool } from "mysql2/promise";
var Connection = class {
  constructor(config) {
    this.config = config;
    this.client = createPool({ multipleStatements: true, ...this.config });
  }
  client;
  async disconnect() {
    await this.client.end();
  }
};

// src/column/column.ts
var Column = class _Column {
  constructor(_client, _path, name, tableName, databaseName) {
    this._client = _client;
    this._path = _path;
    this.name = name;
    this.tableName = tableName;
    this.databaseName = databaseName;
  }
  static schemaToClauses(schema) {
    const clauses = [`\`${schema.name}\``];
    if (schema.type) clauses.push(schema.type);
    if (schema.nullable !== void 0 && !schema.nullable) clauses.push("NOT NULL");
    if (schema.primaryKey) clauses.push("PRIMARY KEY");
    if (schema.autoIncrement) clauses.push("AUTO_INCREMENT");
    if (schema.default !== void 0) clauses.push(`DEFAULT ${schema.default}`);
    return [...clauses, ...schema.clauses || []].filter(Boolean).join(" ");
  }
  static async drop(client, databaseName, tableName, name) {
    return client.execute(`      ALTER TABLE ${databaseName}.${tableName} DROP COLUMN ${name}
    `);
  }
  static normalizeInfo(info) {
    return {
      name: info.Field,
      type: info.Type,
      null: info.Null,
      key: info.Key,
      default: info.Default,
      extra: info.Extra
    };
  }
  static async modify(client, path, name, schema) {
    const clauses = _Column.schemaToClauses({ type: "", ...schema, name });
    return client.execute(`      ALTER TABLE ${path} MODIFY COLUMN ${clauses}
    `);
  }
  static async rename(client, path, name, newName) {
    const result = await client.execute(`      ALTER TABLE ${path} CHANGE ${name} ${newName}
    `);
    return result;
  }
  static async showInfo(client, databaseName, tableName, name) {
    const [rows] = await client.query(`SHOW COLUMNS IN ${tableName} IN ${databaseName} LIKE '${name}'`);
    return _Column.normalizeInfo(rows[0]);
  }
  async drop() {
    return _Column.drop(this._client, this.databaseName, this.tableName, this.name);
  }
  async modify(...args) {
    return _Column.modify(this._client, this._path, this.name, ...args);
  }
  async rename(...[newName, ...args]) {
    const result = await _Column.rename(this._client, this._path, this.name, newName, ...args);
    this.name = newName;
    return result;
  }
  async showInfo() {
    return _Column.showInfo(this._client, this.databaseName, this.tableName, this.name);
  }
};

// src/column/manager.ts
var ColumnManager = class {
  constructor(_client, tableName, databaseName) {
    this._client = _client;
    this.tableName = tableName;
    this.databaseName = databaseName;
    this._path = [databaseName, tableName].join(".");
  }
  _path;
  use(name) {
    return new Column(this._client, this._path, name, this.tableName, this.databaseName);
  }
  async add(schema) {
    const clauses = Column.schemaToClauses(schema);
    await this._client.execute(`      ALTER TABLE ${this.databaseName}.${this.tableName} ADD COLUMN ${clauses}
    `);
    return new Column(
      this._client,
      this._path,
      schema.name,
      this.tableName,
      this.databaseName
    );
  }
  async drop(name) {
    return Column.drop(this._client, this.databaseName, this.tableName, name);
  }
  async modify(name, ...args) {
    return Column.modify(this._client, this._path, name, ...args);
  }
  async rename(name, ...args) {
    return Column.rename(this._client, this._path, name, ...args);
  }
  async showInfo(name, ...args) {
    return Column.showInfo(this._client, this.databaseName, this.tableName, name, ...args);
  }
};

// src/query/builder.ts
import { escape } from "mysql2";
var ALIAS_PATTERN = /(.+)\s+AS\s+(.+)/i;
function extractSelectClauseAliases(selectClauses = []) {
  return selectClauses.map((column) => {
    const match = column.match(ALIAS_PATTERN);
    return match ? match[2]?.trim() : null;
  }).filter((alias) => alias !== null);
}
function isJoinColumn(column, joinClauses = []) {
  for (const clause of joinClauses) {
    if (column.startsWith(`${clause.as}.`)) {
      return true;
    }
  }
  return false;
}
var QueryBuilder = class {
  constructor(_databaseName, _tableName) {
    this._databaseName = _databaseName;
    this._tableName = _tableName;
  }
  buildJoinClause(clauses) {
    if (!clauses || clauses.length === 0) return "";
    return clauses.map((clause) => {
      let left = String(clause.on[0]);
      left = isJoinColumn(left, clauses) ? left : `${this._tableName}.${left}`;
      let right = String(clause.on[2]);
      right = isJoinColumn(right, clauses) ? right : `${clause.as}.${right}`;
      const joinType = clause.type ? `${clause.type} JOIN` : "JOIN";
      const tableName = `${this._databaseName}.${String(clause.table)} AS ${clause.as}`;
      const onCondition = `${left} ${clause.on[1]} ${right}`;
      return `${joinType} ${tableName} ON ${onCondition}`;
    }).join(" ");
  }
  buildSelectClause(clauses, joinClauses) {
    let _clauses = clauses?.length ? clauses : [];
    if (!clauses?.length) {
      _clauses.push("*");
    }
    if (joinClauses?.length) {
      if (!clauses?.length) {
        _clauses = [..._clauses, ...joinClauses.map((join) => `${join.as}.*`)];
      }
      _clauses = _clauses.map((column) => {
        const _column = String(column);
        if (isJoinColumn(_column, joinClauses)) {
          const [tableName, columnName] = _column.split(".");
          return `${_column}${!_column.endsWith("*") ? ` AS ${tableName}_${columnName}` : ""}`;
        }
        if (ALIAS_PATTERN.test(_column)) {
          return _column;
        }
        return `${this._tableName}.${_column}${!_column.endsWith("*") ? ` AS ${_column}` : ""}`;
      });
    }
    return `SELECT ${_clauses.join(", ")}`;
  }
  buildFromClause(hasJoinClauses) {
    return `FROM ${this._databaseName}.${this._tableName}${hasJoinClauses ? ` AS ${this._tableName}` : ""}`;
  }
  buildWhereCondition(column, operator, value) {
    switch (operator) {
      case "eq":
        return `${column} = ${escape(value)}`;
      case "ne":
        return `${column} != ${escape(value)}`;
      case "gt":
        return `${column} > ${escape(value)}`;
      case "gte":
        return `${column} >= ${escape(value)}`;
      case "lt":
        return `${column} < ${escape(value)}`;
      case "lte":
        return `${column} <= ${escape(value)}`;
      case "in":
        return `${column} IN (${value.map(escape).join(", ")})`;
      case "nin":
        return `${column} NOT IN (${value.map(escape).join(", ")})`;
      case "like":
        return `${column} LIKE ${escape(value)}`;
      default:
        throw new Error(`Unsupported operator: ${operator}`);
    }
  }
  buildWhereClause(clauses, joinClauses) {
    if (!clauses || !Object.keys(clauses).length) return "";
    const _clauses = [];
    for (const [column, value] of Object.entries(clauses)) {
      if (value === void 0) continue;
      if (column === "OR" && Array.isArray(value)) {
        _clauses.push(`(${value.map((v) => `(${this.buildWhereClause(v, joinClauses)})`).join(" OR ")})`);
      } else if (column === "NOT" && typeof value === "object") {
        _clauses.push(`NOT (${this.buildWhereClause(value, joinClauses)})`);
      } else if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        for (const [operator, _value] of Object.entries(value)) {
          if (_value === void 0) continue;
          const _column = joinClauses?.length ? isJoinColumn(column, joinClauses) ? column : `${this._tableName}.${column}` : column;
          _clauses.push(this.buildWhereCondition(_column, operator, _value));
        }
      } else {
        const _column = joinClauses?.length ? isJoinColumn(column, joinClauses) ? column : `${this._tableName}.${column}` : column;
        _clauses.push(this.buildWhereCondition(_column, "eq", value));
      }
    }
    if (!_clauses.length) return "";
    return `WHERE ${_clauses.join(" AND ")}`;
  }
  buildGroupByClause(clauses, joinClauses, aliases) {
    if (!clauses || !clauses.length) return "";
    const _clauses = clauses.map((column) => {
      const _column = String(column);
      if (aliases?.includes(_column)) {
        return _column;
      }
      return joinClauses?.length ? isJoinColumn(_column, joinClauses) ? _column : `${this._tableName}.${_column}` : _column;
    });
    return `GROUP BY ${_clauses.join(", ")}`;
  }
  buildOrderByClause(clauses, joinClauses, aliases) {
    if (!clauses) return "";
    const condition = Object.entries(clauses).map(([column, direction = "asc"]) => {
      let _column = String(column);
      if (aliases?.includes(_column)) {
        return _column;
      }
      _column = joinClauses?.length ? isJoinColumn(_column, joinClauses) ? _column : `${this._tableName}.${_column}` : _column;
      return `${_column} ${direction.toUpperCase()}`;
    }).join(", ");
    return condition ? `ORDER BY ${condition}` : "";
  }
  buildLimitClause(limit) {
    return typeof limit === "number" ? `LIMIT ${limit}` : "";
  }
  buildOffsetClause(offset) {
    return typeof offset === "number" ? `OFFSET ${offset}` : "";
  }
  buildClauses(params) {
    const aliases = extractSelectClauseAliases(params?.select);
    return {
      select: this.buildSelectClause(params?.select, params?.join),
      from: this.buildFromClause(Boolean(params?.join?.length)),
      join: this.buildJoinClause(params?.join),
      where: this.buildWhereClause(params?.where, params?.join),
      groupBy: this.buildGroupByClause(params?.groupBy, params?.join, aliases),
      orderBy: this.buildOrderByClause(params?.orderBy, params?.join, aliases),
      limit: this.buildLimitClause(params?.limit),
      offset: this.buildOffsetClause(params?.offset)
    };
  }
  buildQuery(params) {
    return Object.values(this.buildClauses(params)).filter(Boolean).join(" ").trim();
  }
};

// src/table/table.ts
var Table = class _Table {
  constructor(_client, name, databaseName, _ai) {
    this._client = _client;
    this.name = name;
    this.databaseName = databaseName;
    this._ai = _ai;
    this._path = [databaseName, name].join(".");
    this.column = new ColumnManager(this._client, this.name, this.databaseName);
  }
  _path;
  vScoreKey = "v_score";
  column;
  get ai() {
    if (!this._ai) {
      throw new Error("AI instance is undefined. Ensure ai is properly initialized before accessing.");
    }
    return this._ai;
  }
  static schemaToClauses(schema) {
    const clauses = [
      ...Object.entries(schema.columns).map(([name, schema2]) => {
        return Column.schemaToClauses({ ...schema2, name });
      })
    ];
    if (schema.primaryKeys?.length) clauses.push(`PRIMARY KEY (${schema.primaryKeys.join(", ")})`);
    if (schema.fulltextKeys?.length) clauses.push(`FULLTEXT KEY (${schema.fulltextKeys.join(", ")})`);
    return [...clauses, ...schema.clauses || []].filter(Boolean).join(", ");
  }
  static normalizeInfo(info, extended) {
    const name = info[Object.keys(info).find((key) => key.startsWith("Tables_in_"))];
    if (!extended) return { name };
    return {
      name,
      tableType: info.Table_type,
      distributed: !!info.distributed,
      storageType: info.Storage_type
    };
  }
  static async drop(client, databaseName, name) {
    return client.execute(`      DROP TABLE IF EXISTS ${databaseName}.${name}
    `);
  }
  static async truncate(client, databaseName, tableName) {
    return client.execute(`      TRUNCATE TABLE ${databaseName}.${tableName}
    `);
  }
  static async rename(client, databaseName, name, newName) {
    return client.execute(`      ALTER TABLE ${databaseName}.${name} RENAME TO ${newName}
    `);
  }
  async drop() {
    return _Table.drop(this._client, this.databaseName, this.name);
  }
  async showInfo(extended) {
    const clauses = [`SHOW TABLES IN ${this.databaseName}`];
    if (extended) clauses.push("EXTENDED");
    clauses.push(`LIKE '${this.name}'`);
    const [rows] = await this._client.query(clauses.join(" "));
    return _Table.normalizeInfo(rows[0], extended);
  }
  async showColumnsInfo() {
    const [rows] = await this._client.query(`SHOW COLUMNS IN ${this.name} IN ${this.databaseName}`);
    return rows.map((row) => Column.normalizeInfo(row));
  }
  async truncate() {
    return _Table.truncate(this._client, this.databaseName, this.name);
  }
  async rename(...[newName, ...args]) {
    const result = await _Table.rename(this._client, this.databaseName, this.name, newName, ...args);
    this.name = newName;
    return result;
  }
  async insert(values) {
    const _values = Array.isArray(values) ? values : [values];
    const keys = Object.keys(_values[0]);
    const placeholders = `(${keys.map(() => "?").join(", ")})`;
    return Promise.all(
      _values.map((data) => {
        const query = `INSERT INTO ${this._path} (${keys}) VALUES ${placeholders}`;
        return this._client.execute(query, Object.values(data));
      })
    );
  }
  async find(params) {
    const queryBuilder = new QueryBuilder(this.databaseName, this.name);
    const query = queryBuilder.buildQuery(params);
    const [rows] = await this._client.execute(query);
    return rows;
  }
  async update(values, where) {
    const _where = new QueryBuilder(this.databaseName, this.name).buildWhereClause(where);
    const columnAssignments = Object.keys(values).map((key) => `${key} = ?`).join(", ");
    const query = `UPDATE ${this._path} SET ${columnAssignments} ${_where}`;
    return this._client.execute(query, Object.values(values));
  }
  delete(where) {
    if (!where) return this.truncate();
    const _where = new QueryBuilder(this.databaseName, this.name).buildWhereClause(where);
    const query = `DELETE FROM ${this._path} ${_where}`;
    return this._client.execute(query);
  }
  async vectorSearch(params, queryParams) {
    const clauses = new QueryBuilder(this.databaseName, this.name).buildClauses(queryParams);
    const promptEmbedding = (await this.ai.embeddings.create(params.prompt, params.embeddingParams))[0] || [];
    let orderByClause = `ORDER BY ${this.vScoreKey} DESC`;
    if (clauses.orderBy) {
      orderByClause += clauses.orderBy.replace(/^ORDER BY /, ", ");
    }
    const query = `      SET @promptEmbedding = '${JSON.stringify(promptEmbedding)}' :> vector(${promptEmbedding.length}) :> blob;
      ${[clauses.select, `${params.vectorColumn} <*> @promptEmbedding AS ${this.vScoreKey}`].join(", ")}
      FROM ${this._path}
      ${[clauses.where, clauses.groupBy, orderByClause, clauses.limit, clauses.offset].join(" ")}
    `;
    const [rows] = await this._client.execute(query);
    return rows[1];
  }
  async createChatCompletion(params, queryParams) {
    const { prompt, systemRole, template, vectorColumn, embeddingParams, ...createChatCompletionParams } = params;
    const _systemRole = systemRole ?? `      You are a helpful assistant.      Answer the user's question based on the context provided.      If the context provided doesn't answer the question asked don't answer the user's question.      `;
    const _template = template ?? `The user asked: <question>
The most similar context: <context>`;
    const context = prompt ? await this.vectorSearch({ prompt, vectorColumn, embeddingParams }, queryParams) : "";
    const _prompt = _template.replace("<question>", prompt).replace("<context>", JSON.stringify(context));
    return await this.ai.chatCompletions.create({
      ...createChatCompletionParams,
      prompt: _prompt,
      systemRole: _systemRole
    });
  }
};

// src/table/manager.ts
var TableManager = class _TableManager {
  constructor(_client, _ai, databaseName) {
    this._client = _client;
    this._ai = _ai;
    this.databaseName = databaseName;
  }
  static async create(client, databaseName, schema, ai) {
    const clauses = Table.schemaToClauses(schema);
    await client.execute(`      CREATE TABLE IF NOT EXISTS ${databaseName}.${schema.name} (${clauses})
    `);
    return new Table(client, schema.name, databaseName, ai);
  }
  use(name) {
    return new Table(this._client, name, this.databaseName, this._ai);
  }
  async create(schema) {
    return _TableManager.create(this._client, this.databaseName, schema, this._ai);
  }
  async drop(name, ...args) {
    return Table.drop(this._client, this.databaseName, name, ...args);
  }
  async truncate(name, ...args) {
    return Table.truncate(this._client, this.databaseName, name, ...args);
  }
  async rename(name, ...args) {
    return Table.rename(this._client, this.databaseName, name, ...args);
  }
};

// src/database/database.ts
var Database = class _Database {
  constructor(_client, _ai, name, workspaceName) {
    this._client = _client;
    this._ai = _ai;
    this.name = name;
    this.workspaceName = workspaceName;
    this.table = new TableManager(this._client, this._ai, this.name);
  }
  table;
  static async drop(client, name) {
    return client.execute(`DROP DATABASE IF EXISTS ${name}`);
  }
  static normalizeInfo(info, extended) {
    const name = info[Object.keys(info).find((key) => key.startsWith("Database"))];
    if (!extended) return { name };
    return {
      name,
      commits: info.Commits,
      role: info.Role,
      state: info.State,
      position: info.Position,
      details: info.Details,
      asyncSlaves: info.AsyncSlaves,
      syncSlaves: info.SyncSlaves,
      consensusSlaves: info.ConsensusSlaves,
      committedPosition: info.CommittedPosition,
      hardenedPosition: info.HardenedPosition,
      replayPosition: info.ReplayPosition,
      term: info.Term,
      lastPageTerm: info.LastPageTerm,
      memoryMBs: info["Memory (MBs)"],
      pendingIOs: info["Pending IOs"],
      pendingBlobFSyncs: info["Pending blob fsyncs"]
    };
  }
  async drop(...args) {
    return _Database.drop(this._client, this.name, ...args);
  }
  async showInfo(extended) {
    const clauses = ["SHOW DATABASES"];
    if (extended) clauses.push("EXTENDED");
    clauses.push(`LIKE '${this.name}'`);
    const [rows] = await this._client.query(clauses.join(" "));
    return _Database.normalizeInfo(rows[0], extended);
  }
  async showTablesInfo(extended) {
    const clauses = [`SHOW TABLES IN ${this.name}`];
    if (extended) clauses.push("EXTENDED");
    const [rows] = await this._client.query(clauses.join(" "));
    return rows.map((row) => {
      return Table.normalizeInfo(row, extended);
    });
  }
  async describe() {
    const [info, tablesInfo] = await Promise.all([this.showInfo(true), this.showTablesInfo(true)]);
    return {
      ...info,
      tables: await Promise.all(
        tablesInfo.map(async (tableInfo) => {
          const table = this.table.use(tableInfo.name);
          return { ...tableInfo, columns: await table.showColumnsInfo() };
        })
      )
    };
  }
  async query(statement) {
    const statements = [`USE ${this.name}`, statement].join(";\n");
    const [rows] = await this._client.execute(statements);
    return rows.slice(1);
  }
};

// src/database/manager.ts
var DatabaseManager = class {
  constructor(_client, _ai, workspaceName) {
    this._client = _client;
    this._ai = _ai;
    this.workspaceName = workspaceName;
  }
  use(name) {
    return new Database(this._client, this._ai, name, this.workspaceName);
  }
  async create(schema) {
    const clauses = [`CREATE DATABASE IF NOT EXISTS ${schema.name}`];
    if (this.workspaceName) clauses.push(`ON WORKSPACE \`${this.workspaceName}\``);
    await this._client.execute(clauses.join(" "));
    if (schema.tables) {
      await Promise.all(
        Object.entries(schema.tables).map(([name, tableSchema]) => {
          return TableManager.create(this._client, schema.name, { ...tableSchema, name }, this._ai);
        })
      );
    }
    return new Database(this._client, this._ai, schema.name, this.workspaceName);
  }
  async drop(...args) {
    return Database.drop(this._client, ...args);
  }
};

// src/workspace/connection.ts
var WorkspaceConnection = class _WorkspaceConnection extends Connection {
  name;
  _ai;
  database;
  constructor({ name, ai, ...config }) {
    super(config);
    this.name = name;
    this._ai = ai;
    this.database = new DatabaseManager(this.client, this._ai, this.name);
  }
  static create(config) {
    return new _WorkspaceConnection(config);
  }
};

// src/workspace/private-connection/manager.ts
import { URLSearchParams as URLSearchParams2 } from "url";
var WorkspacePrivateConnectionManager = class _WorkspacePrivateConnectionManager extends APIManager {
  constructor(api, _workspaceID, _groupID) {
    super(api);
    this._workspaceID = _workspaceID;
    this._groupID = _groupID;
    this._baseURL = _WorkspacePrivateConnectionManager.getBaseURL(this._workspaceID);
  }
  _baseURL;
  static getBaseURL(workspaceID) {
    return `/workspaces/${workspaceID}/privateConnections`;
  }
  async get(params) {
    const searchParams = new URLSearchParams2({ workspaceGroupID: this._groupID });
    return this._execute(
      `${params?.isKai ? "/kai" : ""}?${searchParams.toString()}`
    );
  }
  async outbundAllowList() {
    return this._execute("/outbundAllowList");
  }
};

// src/workspace/workspace.ts
var Workspace = class _Workspace extends APIManager {
  constructor(api, _ai, id, groupID, name, endpoint, size, state, scaleFactor, scalingProgress, cacheConfig, kaiEnabled, deploymentType, createdAt, lastResumedAt, terminatedAt, autoSuspend, resumeAttachments) {
    super(api);
    this._ai = _ai;
    this.id = id;
    this.groupID = groupID;
    this.name = name;
    this.endpoint = endpoint;
    this.size = size;
    this.state = state;
    this.scaleFactor = scaleFactor;
    this.scalingProgress = scalingProgress;
    this.cacheConfig = cacheConfig;
    this.kaiEnabled = kaiEnabled;
    this.deploymentType = deploymentType;
    this.createdAt = createdAt;
    this.lastResumedAt = lastResumedAt;
    this.terminatedAt = terminatedAt;
    this.autoSuspend = autoSuspend;
    this.resumeAttachments = resumeAttachments;
    this._baseURL = _Workspace.getBaseURL(this.id);
    this.privateConnection = new WorkspacePrivateConnectionManager(this._api, this.id, this.groupID);
  }
  _baseURL;
  privateConnection;
  static getBaseURL(id) {
    return `/workspaces/${id}`;
  }
  static async update(api, id, body) {
    const response = await api.execute(this.getBaseURL(id), {
      method: "PATCH",
      body: JSON.stringify(body)
    });
    return response.workspaceID;
  }
  static async delete(api, id) {
    const response = await api.execute(this.getBaseURL(id), {
      method: "DELETE"
    });
    return response.workspaceID;
  }
  static async resume(api, id, body = {}) {
    const response = await api.execute(`${this.getBaseURL(id)}/resume`, {
      method: "POST",
      body: JSON.stringify(body)
    });
    return response.workspaceID;
  }
  static async suspend(api, id) {
    const response = await api.execute(`${this.getBaseURL(id)}/suspend`, {
      method: "POST"
    });
    return response.workspaceID;
  }
  static async getState(api, id) {
    const searchParams = new URLSearchParams({ fields: "state" });
    const respone = await api.execute(`${this.getBaseURL(id)}?${searchParams.toString()}`);
    return respone.state;
  }
  connect(config) {
    return WorkspaceConnection.create({ ...config, name: this.name, ai: this._ai, host: this.endpoint });
  }
  async update(body) {
    return _Workspace.update(this._api, this.id, body);
  }
  async delete() {
    return _Workspace.delete(this._api, this.id);
  }
  async resume(body) {
    return _Workspace.resume(this._api, this.id, body);
  }
  async suspend() {
    return _Workspace.suspend(this._api, this.id);
  }
  async getState() {
    return _Workspace.getState(this._api, this.id);
  }
};

// src/workspace/manager.ts
var WorkspaceManager = class extends APIManager {
  constructor(api, _ai, _workspaceGroupID) {
    super(api);
    this._ai = _ai;
    this._workspaceGroupID = _workspaceGroupID;
  }
  _baseURL = "/workspaces";
  _create(data) {
    return new Workspace(
      this._api,
      this._ai,
      data.workspaceID,
      data.workspaceGroupID,
      data.name,
      data.endpoint,
      data.size,
      data.state,
      data.scaleFactor,
      data.scalingProgress,
      data.cacheConfig,
      data.kaiEnabled,
      data.deploymentType,
      new Date(data.createdAt),
      data.lastResumedAt ? new Date(data.lastResumedAt) : void 0,
      data.terminatedAt ? new Date(data.terminatedAt) : void 0,
      data.autoSuspend ? {
        ...data.autoSuspend,
        idleChangedAt: data.autoSuspend.idleChangedAt ? new Date(data.autoSuspend.idleChangedAt) : void 0,
        scheduledChangedAt: data.autoSuspend.scheduledChangedAt ? new Date(data.autoSuspend.scheduledChangedAt) : void 0,
        scheduledSuspendAt: data.autoSuspend.scheduledSuspendAt ? new Date(data.autoSuspend.scheduledSuspendAt) : void 0,
        suspendTypeChangedAt: data.autoSuspend.suspendTypeChangedAt ? new Date(data.autoSuspend.suspendTypeChangedAt) : void 0
      } : void 0,
      data.resumeAttachments?.map(({ attachment: type, ...attachment }) => ({ ...attachment, type }))
    );
  }
  async create(body) {
    const response = await this._execute("", {
      method: "POST",
      body: JSON.stringify({ ...body, workspaceGroupID: this._workspaceGroupID })
    });
    if (typeof response === "string") {
      throw new Error(response);
    }
    return this.get({ where: { id: response.workspaceID } });
  }
  async get({ where, select, includeTerminated } = {}) {
    let url = "";
    const searchParams = new URLSearchParams({
      workspaceGroupID: this._workspaceGroupID,
      includeTerminated: includeTerminated ? String(includeTerminated) : String(false)
    });
    if (where) {
      if ("id" in where) {
        url = `${url}/${where.id}`;
      }
    }
    if (select?.length) {
      searchParams.set("fields", select.join(","));
    }
    const response = await this._execute(
      `${url}?${searchParams.toString()}`
    );
    if (Array.isArray(response)) {
      return response.filter((data) => where && "name" in where ? data.name === where.name : true).map((data) => this._create(data));
    }
    return this._create(response);
  }
  async update(...args) {
    return Workspace.update(this._api, ...args);
  }
  async delete(...args) {
    return Workspace.delete(this._api, ...args);
  }
  async resume(...args) {
    return Workspace.resume(this._api, ...args);
  }
  async suspend(...args) {
    return Workspace.suspend(this._api, ...args);
  }
  async getState(...args) {
    return Workspace.getState(this._api, ...args);
  }
};

// ../utils/dist/index.mjs
function getKeyByValue(object, value) {
  for (const key in object) {
    if (object[key] === value) {
      return key;
    }
  }
  return void 0;
}

// src/workspace-group/stage/stage.ts
var WorkspaceGroupStage = class _WorkspaceGroupStage extends APIManager {
  constructor(api, _workspaceGroupID, name, content, type, path, format, mimetype, size, writable, createdAt, modifiedAt) {
    super(api);
    this._workspaceGroupID = _workspaceGroupID;
    this.name = name;
    this.content = content;
    this.type = type;
    this.path = path;
    this.format = format;
    this.mimetype = mimetype;
    this.size = size;
    this.writable = writable;
    this.createdAt = createdAt;
    this.modifiedAt = modifiedAt;
    this._baseURL = _WorkspaceGroupStage.getBaseURL(this._workspaceGroupID, this.path);
  }
  _baseURL;
  static getBaseURL(workspaceGroupID, path) {
    return `/stage/${workspaceGroupID}/fs/${path}`;
  }
  static serializePath(path) {
    if (!path) return "";
    return `/${encodeURIComponent(path.startsWith("/") ? path.substring(1) : path)}`;
  }
  static formatPath(id, path) {
    return this.getBaseURL(id, this.serializePath(path));
  }
  static mergePaths(...paths) {
    return paths.filter(Boolean).join("").replaceAll("//", "/");
  }
  static async get(api, id, path) {
    const response = await api.execute(this.formatPath(id, path));
    if (!response.path) {
      throw new Error(`No stage found with the specified path: ${path}`);
    }
    return new _WorkspaceGroupStage(
      api,
      id,
      response.name,
      response.content,
      response.type,
      response.path,
      response.format,
      response.mimetype,
      response.size,
      response.writable,
      response.created ? new Date(response.created) : void 0,
      response.last_modified ? new Date(response.last_modified) : void 0
    );
  }
  static async update(api, id, path, body) {
    const response = await api.execute(this.formatPath(id, path), {
      method: "PATCH",
      body: JSON.stringify({
        ...body,
        newPath: body.newPath || void 0
      })
    });
    if (typeof response === "string") {
      throw new Error(response);
    }
    return response;
  }
  static async delete(api, id, path) {
    const response = await api.execute(this.formatPath(id, path), {
      method: "DELETE"
    });
    if (typeof response === "string") {
      throw new Error(response);
    }
    return response;
  }
  static async createFolder(api, id, path, name) {
    const response = await api.execute(
      `${this.formatPath(id, path)}${encodeURIComponent(name)}/`,
      { method: "PUT" }
    );
    if (typeof response === "string") {
      throw new Error(response);
    }
    return this.get(api, id, response.path);
  }
  // TODO: Complete this method
  static async uploadFile(api, id, path, file) {
    const formData = new FormData();
    formData.append("file", file);
    const response = await api.execute(`${this.formatPath(id, path)}/${this.serializePath(file.name)}`, {
      method: "PUT",
      headers: { "Content-Type": "multipart/form-data" },
      body: formData
    });
  }
  async get(path) {
    const _path = _WorkspaceGroupStage.mergePaths(this.path, path);
    return _WorkspaceGroupStage.get(this._api, this._workspaceGroupID, _path);
  }
  async update(body, path) {
    const _path = _WorkspaceGroupStage.mergePaths(this.path, path);
    return _WorkspaceGroupStage.update(this._api, this._workspaceGroupID, _path, body);
  }
  async delete(path) {
    const _path = _WorkspaceGroupStage.mergePaths(this.path, path);
    return _WorkspaceGroupStage.delete(this._api, this._workspaceGroupID, _path);
  }
  async createFolder(name, path) {
    const _path = _WorkspaceGroupStage.mergePaths(this.path, path);
    return _WorkspaceGroupStage.createFolder(this._api, this._workspaceGroupID, _path, name);
  }
  async uploadFile(file, path) {
    const _path = _WorkspaceGroupStage.mergePaths(this.path, path);
    return _WorkspaceGroupStage.uploadFile(this._api, this._workspaceGroupID, _path, file);
  }
};

// src/workspace-group/stage/manager.ts
var WorkspaceGroupStageManager = class _WorkspaceGroupStageManager extends APIManager {
  constructor(api, _workspaceGroupID) {
    super(api);
    this._workspaceGroupID = _workspaceGroupID;
    this._baseURL = _WorkspaceGroupStageManager.getBaseURL(this._workspaceGroupID);
  }
  _baseURL;
  static getBaseURL(workspaceGroupID) {
    return `/stage/${workspaceGroupID}/fs`;
  }
  async get(...args) {
    return WorkspaceGroupStage.get(this._api, this._workspaceGroupID, ...args);
  }
  async update(...args) {
    return WorkspaceGroupStage.update(this._api, this._workspaceGroupID, ...args);
  }
  async delete(...args) {
    return WorkspaceGroupStage.delete(this._api, this._workspaceGroupID, ...args);
  }
  async createFolder(...args) {
    return WorkspaceGroupStage.createFolder(this._api, this._workspaceGroupID, ...args);
  }
};

// src/workspace-group/storage/manager.ts
var WorkspaceGroupStorageManager = class _WorkspaceGroupStorageManager extends APIManager {
  constructor(api, _workspaceGroupID) {
    super(api);
    this._workspaceGroupID = _workspaceGroupID;
    this._baseURL = _WorkspaceGroupStorageManager.getBaseURL(this._workspaceGroupID);
  }
  _baseURL;
  static getBaseURL(workspaceGroupID) {
    return `/workspaceGroups/${workspaceGroupID}/storage`;
  }
  async getStatus() {
    return this._execute("/DR/status");
  }
  async getRegions() {
    const response = await this._execute("/DR/regions");
    return response.map((data) => ({ id: data.regionID, name: data.region, provider: data.provider }));
  }
};

// src/workspace-group/workspace-group.ts
var updateWindowDaysMap = {
  0: "su",
  1: "mo",
  2: "tu",
  3: "we",
  4: "th",
  5: "fr",
  6: "sa"
};
var WorkspaceGroup = class _WorkspaceGroup extends APIManager {
  constructor(api, _ai, _organization, id, name, regionID, state, smartDRStatus, allowAllTraffic, firewallRanges, updateWindow, createdAt, expiresAt, terminatedAt) {
    super(api);
    this._ai = _ai;
    this._organization = _organization;
    this.id = id;
    this.name = name;
    this.regionID = regionID;
    this.state = state;
    this.smartDRStatus = smartDRStatus;
    this.allowAllTraffic = allowAllTraffic;
    this.firewallRanges = firewallRanges;
    this.updateWindow = updateWindow;
    this.createdAt = createdAt;
    this.expiresAt = expiresAt;
    this.terminatedAt = terminatedAt;
    this._baseURL = _WorkspaceGroup.getBaseURL(this.id);
    this.stage = new WorkspaceGroupStageManager(this._api, this.id);
    this.storage = new WorkspaceGroupStorageManager(this._api, this.id);
    this.workspace = new WorkspaceManager(this._api, this._ai, this.id);
  }
  _baseURL;
  stage;
  storage;
  workspace;
  static getBaseURL(id) {
    return `/workspaceGroups/${id}`;
  }
  static serializeUpdateWindow(updateWindow) {
    const day = getKeyByValue(updateWindowDaysMap, updateWindow.day);
    if (!day) {
      throw new Error(
        `Day not found with the given name. Please provide a valid day from the following list: ${Object.values(updateWindowDaysMap).join(", ")}.`
      );
    }
    return { ...updateWindow, day: Number(day) };
  }
  static async update(api, id, body) {
    const expiresAt = body.expiresAt ? body.expiresAt.toISOString().split(".")[0] + "Z" : void 0;
    const updateWindow = body.updateWindow ? _WorkspaceGroup.serializeUpdateWindow(body.updateWindow) : void 0;
    const response = await api.execute(this.getBaseURL(id), {
      method: "PATCH",
      body: JSON.stringify({ ...body, expiresAt, updateWindow })
    });
    return response.workspaceGroupID;
  }
  static async delete(api, id, force) {
    const params = new URLSearchParams({ force: force ? String(force) : String(false) });
    const response = await api.execute(
      `${this.getBaseURL(id)}?${params.toString()}`,
      { method: "DELETE" }
    );
    return response.workspaceGroupID;
  }
  async update(...args) {
    return _WorkspaceGroup.update(this._api, this.id, ...args);
  }
  async delete(...args) {
    return _WorkspaceGroup.delete(this._api, this.id, ...args);
  }
  async getPrivateConnections() {
    const response = await this._execute(`/privateConnections`);
    return response.map((data) => ({
      ...data,
      createdAt: new Date(data.createdAt),
      deletedAt: new Date(data.deletedAt),
      updatedAt: new Date(data.updatedAt),
      activeAt: new Date(data.activeAt)
    }));
  }
  async getMetrics() {
    const org = await this._organization.get();
    return this._api.execute(`/organizations/${org.id}${_WorkspaceGroup.getBaseURL(this.id)}/metrics`, {
      version: 2
    });
  }
};

// src/workspace-group/manager.ts
var WorkspaceGroupManager = class extends APIManager {
  constructor(_api, _ai, _organization, _region) {
    super(_api);
    this._ai = _ai;
    this._organization = _organization;
    this._region = _region;
  }
  _baseURL = "/workspaceGroups";
  _create(data) {
    return new WorkspaceGroup(
      this._api,
      this._ai,
      this._organization,
      data.workspaceGroupID,
      data.name,
      data.regionID,
      data.state,
      data.smartDRStatus,
      data.allowAllTraffic,
      data.firewallRanges,
      data.updateWindow ? { ...data.updateWindow, day: updateWindowDaysMap[data.updateWindow.day] } : void 0,
      new Date(data.createdAt),
      data.expiresAt ? new Date(data.expiresAt) : void 0,
      data.terminatedAt ? new Date(data.terminatedAt) : void 0
    );
  }
  async create({ regionName, firewallRanges = [], ...body }) {
    const region = await this._region.get({ name: regionName });
    if (!region) {
      throw new Error("Region not found with the given name. Please provide a valid region name.");
    }
    const updateWindow = body.updateWindow ? WorkspaceGroup.serializeUpdateWindow(body.updateWindow) : void 0;
    const response = await this._execute("", {
      method: "POST",
      body: JSON.stringify({ ...body, firewallRanges, updateWindow, regionID: region.id })
    });
    const newWorkspaceGroup = await this._execute(`/${response.workspaceGroupID}`);
    return {
      workspaceGroup: this._create(newWorkspaceGroup),
      adminPassword: body.adminPassword || response.adminPassword
    };
  }
  async get({ where, select, includeTerminated } = {}) {
    let url = "";
    const searchParams = new URLSearchParams({
      includeTerminated: includeTerminated ? String(includeTerminated) : String(false)
    });
    if (where) {
      if ("id" in where) {
        url = `${url}/${where.id}`;
      }
    }
    if (select?.length) {
      searchParams.set("fields", select.join(","));
    }
    const response = await this._execute(
      `${url}?${searchParams.toString()}`
    );
    if (Array.isArray(response)) {
      return response.filter((data) => where && "name" in where ? data.name === where.name : true).map((data) => this._create(data));
    }
    return this._create(response);
  }
  async update(...args) {
    return WorkspaceGroup.update(this._api, ...args);
  }
  async delete(...args) {
    return WorkspaceGroup.delete(this._api, ...args);
  }
};

// src/client.ts
var SingleStoreClient = class {
  _ai;
  _api;
  billing;
  job;
  organization;
  region;
  secret;
  team;
  workspaceGroup;
  constructor(config) {
    this._ai = config?.ai;
    this._api = new API(config?.apiKey);
    this.billing = new BillingManager(this._api);
    this.job = new JobManager(this._api);
    this.organization = new OrganizationManager(this._api);
    this.region = new RegionManager(this._api);
    this.secret = new SecretManager(this._api);
    this.team = new TeamManager(this._api);
    this.workspaceGroup = new WorkspaceGroupManager(this._api, this._ai, this.organization, this.region);
  }
  connect(config) {
    return WorkspaceConnection.create({ ...config, ai: this._ai });
  }
};
export {
  SingleStoreClient,
  escape2 as escape
};
//# sourceMappingURL=index.mjs.map