import * as mysql2_promise from 'mysql2/promise';
import { Pool, PoolOptions, ResultSetHeader, FieldPacket } from 'mysql2/promise';
export { FieldPacket, ResultSetHeader, RowDataPacket } from 'mysql2/promise';
export { escape } from 'mysql2';
import { AnyAI, CreateChatCompletionResult } from '@singlestore/ai';

interface ConnectionConfig$1 extends Partial<Omit<PoolOptions, "name">> {
}
type ConnectionClient = Pool;
declare class Connection {
    config: ConnectionConfig$1;
    client: ConnectionClient;
    constructor(config: ConnectionConfig$1);
    disconnect(): Promise<void>;
}

type Defined<T> = Exclude<T, undefined>;
type Optional<T extends Record<any, any>, K extends keyof T> = Omit<T, K> & {
    [C in keyof Pick<T, K>]?: T[C];
};
type Tail<T extends any[]> = T extends [any, ...infer Rest] ? Rest : never;

type ColumnName = string;
type ColumnType = any;
interface ColumnSchema {
    name: ColumnName;
    type: string;
    nullable: boolean;
    primaryKey: boolean;
    autoIncrement: boolean;
    default: any;
    clauses: string[];
}
interface AddColumnSchema extends Optional<ColumnSchema, "nullable" | "primaryKey" | "autoIncrement" | "default" | "clauses"> {
}
interface ColumnInfo<TName extends ColumnName> {
    name: TName;
    type: string;
    null: string;
    key: string;
    default: any;
    extra: string;
}
declare class Column<TName extends ColumnName, TTableName extends TableName, TDatabaseName extends DatabaseName> {
    private _client;
    private _path;
    name: TName;
    tableName: TTableName;
    databaseName: TDatabaseName;
    constructor(_client: ConnectionClient, _path: string, name: TName, tableName: TTableName, databaseName: TDatabaseName);
    static schemaToClauses(schema: Partial<ColumnSchema>): string;
    static drop<TName extends ColumnName, TTableName extends TableName, TDatabaseName extends DatabaseName>(client: ConnectionClient, databaseName: TDatabaseName, tableName: TTableName, name: TName): Promise<[ResultSetHeader, FieldPacket[]]>;
    static normalizeInfo<TName extends ColumnName>(info: any): ColumnInfo<TName>;
    static modify<TName extends ColumnName>(client: ConnectionClient, path: string, name: TName, schema: Partial<Omit<ColumnSchema, "name">>): Promise<[ResultSetHeader, FieldPacket[]]>;
    static rename<TName extends ColumnName>(client: ConnectionClient, path: string, name: TName, newName: ColumnName): Promise<[ResultSetHeader, FieldPacket[]]>;
    static showInfo<TName extends ColumnName, TTableName extends TableName, TDatabaseName extends DatabaseName>(client: ConnectionClient, databaseName: TDatabaseName, tableName: TTableName, name: TName): Promise<ColumnInfo<TName>>;
    drop(): Promise<[ResultSetHeader, FieldPacket[]]>;
    modify(...args: Parameters<typeof Column.modify> extends [any, any, any, ...infer Rest] ? Rest : never): Promise<[ResultSetHeader, FieldPacket[]]>;
    rename(...[newName, ...args]: Parameters<typeof Column.rename> extends [any, any, any, ...infer Rest] ? Rest : never): Promise<[ResultSetHeader, FieldPacket[]]>;
    showInfo(): Promise<ColumnInfo<TName>>;
}

declare class ColumnManager<TTableName extends TableName, TTableType extends TableType, TDatabaseName extends DatabaseName> {
    private _client;
    tableName: TTableName;
    databaseName: TDatabaseName;
    private _path;
    constructor(_client: ConnectionClient, tableName: TTableName, databaseName: TDatabaseName);
    use<TName extends TableColumnName<TTableType> | (ColumnName & {})>(name: TName): Column<TName, TTableName, TDatabaseName>;
    add<TSchema extends AddColumnSchema>(schema: TSchema): Promise<Column<TSchema["name"], TTableName, TDatabaseName>>;
    drop(name: TableColumnName<TTableType> | (ColumnName & {})): Promise<[ResultSetHeader, mysql2_promise.FieldPacket[]]>;
    modify(name: TableColumnName<TTableType> | (ColumnName & {}), ...args: Parameters<typeof Column.modify> extends [any, any, any, ...infer Rest] ? Rest : never): Promise<[ResultSetHeader, mysql2_promise.FieldPacket[]]>;
    rename(name: TableColumnName<TTableType> | (ColumnName & {}), ...args: Parameters<typeof Column.rename> extends [any, any, any, ...infer Rest] ? Rest : never): Promise<[ResultSetHeader, mysql2_promise.FieldPacket[]]>;
    showInfo<TName extends TableColumnName<TTableType> | (ColumnName & {})>(name: TName, ...args: Parameters<typeof Column.showInfo> extends [any, any, any, any, ...infer Rest] ? Rest : never): Promise<ColumnInfo<TName>>;
}

type MergeUnion<T> = (T extends any ? (i: T) => void : never) extends (i: infer U) => void ? {
    [K in keyof U]: U[K];
} : never;
type JoinType = "INNER" | "LEFT" | "RIGHT" | "FULL";
type JoinOperator = "=" | "<" | ">" | "<=" | ">=" | "!=";
type JoinClause<TTableType extends TableType, TDatabaseType extends DatabaseType, TAs extends string> = {
    [K in keyof TDatabaseType["tables"]]: {
        type?: JoinType;
        table: K;
        as: TAs;
        on: [(string & {}) | keyof TTableType, JoinOperator, (string & {}) | keyof TDatabaseType["tables"][K]["columns"]];
    };
}[keyof TDatabaseType["tables"]];
type ExtractJoinClauseColumns<TTableType extends TableType, TDatabaseType extends DatabaseType, TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[]> = {
    [K in TJoinClauses[number] as K["as"]]: `${K["as"]}.${Extract<keyof TDatabaseType["tables"][K["table"]]["columns"], string>}`;
}[TJoinClauses[number]["as"]];
type SelectClause<TTableType extends TableType, TDatabaseType extends DatabaseType, TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[]> = ("*" | keyof TTableType | ExtractJoinClauseColumns<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses> | `${TJoinClauseAs}.*` | `${string} AS ${string}`)[];
type WhereOperator<TColumnValue> = TColumnValue extends string ? {
    eq?: TColumnValue;
    ne?: TColumnValue;
    like?: string;
    in?: TColumnValue[];
    nin?: TColumnValue[];
} : TColumnValue extends number | Date ? {
    eq?: TColumnValue;
    ne?: TColumnValue;
    gt?: TColumnValue;
    gte?: TColumnValue;
    lt?: TColumnValue;
    lte?: TColumnValue;
    in?: TColumnValue[];
    nin?: TColumnValue[];
} : never;
type WhereClause<TTableType extends TableType, TDatabaseType extends DatabaseType, TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[]> = ({
    [K in keyof TTableType]?: WhereOperator<TTableType[K]> | TTableType[K];
} & {
    [K in TJoinClauses[number] as K["as"]]: {
        [C in keyof TDatabaseType["tables"][K["table"]]["columns"] as `${K["as"]}.${Extract<C, string>}`]?: WhereOperator<TDatabaseType["tables"][K["table"]]["columns"][C]> | TDatabaseType["tables"][K["table"]]["columns"][C];
    };
}[TJoinClauses[number]["as"]]) & {
    OR?: WhereClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>[];
    NOT?: WhereClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>;
};
type GroupByClause<TTableType extends TableType, TDatabaseType extends DatabaseType, TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[]> = ((string & {}) | keyof TTableType | ExtractJoinClauseColumns<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>)[];
type OrderByDirection = "asc" | "desc";
type OrderByClause<TTableType extends TableType, TDatabaseType extends DatabaseType, TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[]> = {
    [K in (string & {}) | keyof TTableType | Extract<ExtractJoinClauseColumns<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>, string>]?: OrderByDirection;
};
interface QueryBuilderParams<TTableType extends TableType, TDatabaseType extends DatabaseType, TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[], TSelectClause extends SelectClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>> {
    join?: TJoinClauses;
    select?: TSelectClause;
    where?: WhereClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>;
    groupBy?: GroupByClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>;
    orderBy?: OrderByClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>;
    limit?: number;
    offset?: number;
}
type AnyQueryBuilderParams = QueryBuilderParams<any, any, any, any, any>;
type ExtractSelectedQueryColumns<TTableType extends TableType, TDatabaseType extends DatabaseType, TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[], TSelectClause extends SelectClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>> = TSelectClause extends (infer TColumn)[] ? MergeUnion<TColumn extends "*" ? TTableType : TColumn extends keyof TTableType ? {
    [K in TColumn]: TTableType[K];
} : TColumn extends `${infer TJoinAs}.${infer TJoinColumn}` ? TJoinAs extends TJoinClauseAs ? TJoinColumn extends keyof TDatabaseType["tables"][Extract<TJoinClauses[number], {
    as: TJoinAs;
}>["table"]]["columns"] ? {
    [K in `${TJoinAs}_${TJoinColumn}`]: TDatabaseType["tables"][Extract<TJoinClauses[number], {
        as: TJoinAs;
    }>["table"]]["columns"][TJoinColumn];
} : never : never : TColumn extends `${infer TAlias}.*` ? TAlias extends TJoinClauseAs ? TDatabaseType["tables"][Extract<TJoinClauses[number], {
    as: TAlias;
}>["table"]]["columns"] : never : TColumn extends `${string} AS ${infer TAs}` ? {
    [K in TAs]: any;
} : never> : never;
declare class QueryBuilder<TTableType extends TableType, TDatabaseType extends DatabaseType> {
    private _databaseName;
    private _tableName;
    constructor(_databaseName: string, _tableName: string);
    buildJoinClause<TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[]>(clauses?: TJoinClauses): string;
    buildSelectClause<TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[]>(clauses?: SelectClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>, joinClauses?: TJoinClauses): string;
    buildFromClause(hasJoinClauses?: boolean): string;
    buildWhereCondition(column: string, operator: string, value: any): string;
    buildWhereClause<TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[]>(clauses?: WhereClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>, joinClauses?: TJoinClauses): string;
    buildGroupByClause<TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[]>(clauses?: GroupByClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>, joinClauses?: TJoinClauses, aliases?: string[]): string;
    buildOrderByClause<TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[]>(clauses?: OrderByClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>, joinClauses?: TJoinClauses, aliases?: string[]): string;
    buildLimitClause(limit?: number): string;
    buildOffsetClause(offset?: number): string;
    buildClauses<TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[], TSelectClause extends SelectClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>>(params?: QueryBuilderParams<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses, TSelectClause>): {
        select: string;
        from: string;
        join: string;
        where: string;
        groupBy: string;
        orderBy: string;
        limit: string;
        offset: string;
    };
    buildQuery<TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[], TSelectClause extends SelectClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>>(params?: QueryBuilderParams<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses, TSelectClause>): string;
}

type TableName = string;
interface TableType extends Record<ColumnName, ColumnType> {
}
interface TableSchema<TName extends TableName, TType extends TableType> {
    name: TName;
    columns: {
        [K in keyof TType]: Omit<AddColumnSchema, "name">;
    };
    primaryKeys: string[];
    fulltextKeys: string[];
    clauses: string[];
}
interface CreateTableSchema<TName extends TableName, TType extends TableType> extends Optional<TableSchema<TName, TType>, "primaryKeys" | "fulltextKeys" | "clauses"> {
}
interface TableInfo<TName extends TableName> {
    name: TName;
}
interface TableInfoExtended<TName extends TableName> extends TableInfo<TName> {
    tableType: string;
    distributed: boolean;
    storageType: string;
}
type TableColumnName<TType extends TableType> = Extract<keyof TType, string>;
type VectorScoreKey = "v_score";
declare class Table<TName extends TableName, TType extends TableType, TDatabaseType extends DatabaseType, TAI extends AnyAI | undefined> {
    private _client;
    name: TName;
    databaseName: TDatabaseType["name"];
    private _ai?;
    private _path;
    vScoreKey: VectorScoreKey;
    column: ColumnManager<TName, TType, TDatabaseType["name"]>;
    constructor(_client: ConnectionClient, name: TName, databaseName: TDatabaseType["name"], _ai?: TAI | undefined);
    private get ai();
    static schemaToClauses(schema: CreateTableSchema<TableName, TableType>): string;
    static normalizeInfo<TName extends TableName, TExtended extends boolean, _ReturnType = TExtended extends true ? TableInfoExtended<TName> : TableInfo<TName>>(info: any, extended?: TExtended): _ReturnType;
    static drop<TName extends TableName, TDatabaseName extends DatabaseName>(client: ConnectionClient, databaseName: TDatabaseName, name: TName): Promise<[ResultSetHeader, FieldPacket[]]>;
    static truncate<TName extends TableName, TDatabaseName extends DatabaseName>(client: ConnectionClient, databaseName: TDatabaseName, tableName: TName): Promise<[ResultSetHeader, FieldPacket[]]>;
    static rename<TName extends TableName, TDatabaseName extends DatabaseName>(client: ConnectionClient, databaseName: TDatabaseName, name: TName, newName: TableName): Promise<[ResultSetHeader, FieldPacket[]]>;
    drop(): Promise<[ResultSetHeader, FieldPacket[]]>;
    showInfo<TExtended extends boolean = false>(extended?: TExtended): Promise<TExtended extends true ? TableInfoExtended<TName> : TableInfo<TName>>;
    showColumnsInfo(): Promise<ColumnInfo<Extract<keyof TType, string>>[]>;
    truncate(): Promise<[ResultSetHeader, FieldPacket[]]>;
    rename(...[newName, ...args]: Parameters<typeof Table.rename> extends [any, any, any, ...infer Rest] ? Rest : never): Promise<[ResultSetHeader, FieldPacket[]]>;
    insert(values: Partial<TType> | Partial<TType>[]): Promise<[ResultSetHeader, FieldPacket[]][]>;
    find<TJoinClauseAs extends string, TJoinClauses extends JoinClause<TType, TDatabaseType, TJoinClauseAs>[], TSelectClause extends SelectClause<TType, TDatabaseType, TJoinClauseAs, TJoinClauses>>(params?: QueryBuilderParams<TType, TDatabaseType, TJoinClauseAs, TJoinClauses, TSelectClause>): Promise<ExtractSelectedQueryColumns<TType, TDatabaseType, TJoinClauseAs, TJoinClauses, TSelectClause>[]>;
    update(values: Partial<TType>, where: WhereClause<TType, TDatabaseType, any, any>): Promise<[ResultSetHeader, FieldPacket[]]>;
    delete(where?: WhereClause<TType, TDatabaseType, any, any>): Promise<[ResultSetHeader, FieldPacket[]]>;
    vectorSearch<TJoinClauseAs extends string, TJoinClauses extends JoinClause<TType, TDatabaseType, TJoinClauseAs>[], TSelectClause extends SelectClause<TType, TDatabaseType, TJoinClauseAs, TJoinClauses>, TParams extends {
        prompt: string;
        vectorColumn: TableColumnName<TType>;
        embeddingParams?: TAI extends AnyAI ? Parameters<TAI["embeddings"]["create"]>[1] : never;
    }>(params: TParams, queryParams?: QueryBuilderParams<TType, TDatabaseType, TJoinClauseAs, TJoinClauses, TSelectClause>): Promise<(ExtractSelectedQueryColumns<TType, TDatabaseType, TJoinClauseAs, TJoinClauses, TSelectClause> & {
        v_score: number;
    })[]>;
    createChatCompletion<TJoinClauseAs extends string, TJoinClauses extends JoinClause<TType, TDatabaseType, TJoinClauseAs>[], TSelectClause extends SelectClause<TType, TDatabaseType, TJoinClauseAs, TJoinClauses>, TParams extends Parameters<this["vectorSearch"]>[0] & (TAI extends AnyAI ? Parameters<TAI["chatCompletions"]["create"]>[0] : never) & {
        template?: string;
    }>(params: TParams, queryParams?: QueryBuilderParams<TType, TDatabaseType, TJoinClauseAs, TJoinClauses, TSelectClause>): Promise<CreateChatCompletionResult<TParams["stream"]>>;
}

declare class TableManager<TDatabaseType extends DatabaseType, TAI extends AnyAI | undefined> {
    private _client;
    private _ai;
    databaseName: TDatabaseType["name"];
    constructor(_client: ConnectionClient, _ai: TAI, databaseName: TDatabaseType["name"]);
    static create<TName extends TableName, TType extends TableType, TDatabaseType extends DatabaseType, TAI extends AnyAI | undefined>(client: ConnectionClient, databaseName: TDatabaseType["name"], schema: CreateTableSchema<TName, TType>, ai?: TAI): Promise<Table<TName, TType, TDatabaseType, TAI>>;
    use<TName extends DatabaseTableName<TDatabaseType> | (TableName & {}), TType>(name: TName): Table<TName, TType extends TableType ? TType : TName extends DatabaseTableName<TDatabaseType> ? TDatabaseType["tables"][TName] : TableType, TDatabaseType, TAI>;
    create<TName extends TableName, TType extends TableType>(schema: CreateTableSchema<TName, TType>): Promise<Table<TName, TType, TDatabaseType, TAI>>;
    drop(name: DatabaseTableName<TDatabaseType> | (TableName & {}), ...args: Parameters<typeof Table.drop> extends [any, any, any, ...infer Rest] ? Rest : never): Promise<[ResultSetHeader, mysql2_promise.FieldPacket[]]>;
    truncate(name: DatabaseTableName<TDatabaseType> | (TableName & {}), ...args: Parameters<typeof Table.truncate> extends [any, any, any, ...infer Rest] ? Rest : never): Promise<[ResultSetHeader, mysql2_promise.FieldPacket[]]>;
    rename(name: DatabaseTableName<TDatabaseType> | (TableName & {}), ...args: Parameters<typeof Table.rename> extends [any, any, any, ...infer Rest] ? Rest : never): Promise<[ResultSetHeader, mysql2_promise.FieldPacket[]]>;
}

type APIVersion = 1 | 2;
declare class API {
    private readonly _apiKey?;
    private readonly _version;
    private readonly _baseURL;
    constructor(_apiKey?: string | undefined, _version?: APIVersion);
    execute<T = any>(url: string, { version, ...params }?: RequestInit & {
        version?: APIVersion;
    }): Promise<T>;
}

declare abstract class APIManager {
    protected readonly _api: API;
    protected abstract readonly _baseURL: string;
    constructor(_api: API);
    protected _execute<T = any>(...[url, params]: Partial<Parameters<API["execute"]>>): Promise<T>;
}

interface PrivateConnectionSchema {
    privateConnectionID: string;
    workspaceGroupID: string;
    workspaceID: string;
    serviceName: string;
    type: "INBOUND" | "OUTBOUND";
    status: "PENDING" | "ACTIVE" | "DELETED";
    allowList: string;
    outboundAllowList: string;
    createdAt: string;
    deletedAt: string;
    updatedAt: string;
    activeAt: string;
}
interface PrivateConnection extends Omit<PrivateConnectionSchema, "createdAt" | "deletedAt" | "updatedAt" | "activeAt"> {
    createdAt: Date;
    deletedAt: Date;
    updatedAt: Date;
    activeAt: Date;
}

interface GetWorkspacePrivateConnectionParams<TIsKai extends boolean | undefined> {
    isKai?: TIsKai;
}
declare class WorkspacePrivateConnectionManager extends APIManager {
    private _workspaceID;
    private _groupID;
    protected _baseURL: string;
    constructor(api: API, _workspaceID: WorkspaceSchema["workspaceID"], _groupID: WorkspaceSchema["workspaceGroupID"]);
    static getBaseURL(workspaceID: WorkspaceSchema["workspaceID"]): string;
    get<TIsKai extends boolean | undefined = undefined>(params?: GetWorkspacePrivateConnectionParams<TIsKai>): Promise<TIsKai extends undefined ? PrivateConnectionSchema[] : {
        serviceName: string;
    }>;
    outbundAllowList(): Promise<{
        outboundAllowList: string;
    }[]>;
}

type WorkspaceSize = string;
interface WorkspaceResumeAttachmentSchema {
    attachment: "READWRITE" | "READONLY";
    database: string;
    error: string;
    success: boolean;
}
interface WorkspaceResumeAttachment extends Omit<WorkspaceResumeAttachmentSchema, "attachment"> {
    type: WorkspaceResumeAttachmentSchema["attachment"];
}
interface WorkspaceAutoSuspendSchema {
    suspendType: "IDLE" | "SCHEDULED";
    idleAfterSeconds: number;
    idleChangedAt: string | undefined;
    scheduledChangedAt: string | undefined;
    scheduledSuspendAt: string | undefined;
    suspendTypeChangedAt: string | undefined;
}
interface WorkspaceAutoSuspend extends Omit<WorkspaceAutoSuspendSchema, "idleChangedAt" | "scheduledChangedAt" | "scheduledSuspendAt" | "suspendTypeChangedAt"> {
    idleChangedAt: Date | undefined;
    scheduledChangedAt: Date | undefined;
    scheduledSuspendAt: Date | undefined;
    suspendTypeChangedAt: Date | undefined;
}
interface WorkspaceSchema {
    workspaceID: string;
    workspaceGroupID: string;
    name: string;
    endpoint: string;
    size: WorkspaceSize;
    state: "ACTIVE" | "PENDING" | "SUSPENDED" | "FAILED" | "TERMINATED";
    scaleFactor: 1 | 2 | 4;
    scalingProgress: number | undefined;
    cacheConfig: 1 | 2 | 4;
    kaiEnabled: boolean;
    deploymentType: "PRODUCTION" | "NON-PRODUCTION";
    createdAt: string;
    lastResumedAt: string | undefined;
    terminatedAt: string | undefined;
    autoSuspend: WorkspaceAutoSuspendSchema | undefined;
    resumeAttachments: WorkspaceResumeAttachmentSchema[];
}
interface UpdateWorkspaceBody extends Partial<Pick<WorkspaceSchema, "size" | "deploymentType" | "cacheConfig" | "scaleFactor">> {
    enableKai?: boolean;
    autoSuspend?: {
        suspendType?: WorkspaceAutoSuspendSchema["suspendType"] | "DISABLED";
        suspendAfterSeconds?: number;
    };
}
interface ResumeWorkspaceBody {
    disableAutoSuspend?: boolean;
}
interface ConnectWorkspaceConfig<TName extends WorkspaceSchema["name"] | undefined, TAI extends AnyAI | undefined> extends Omit<CreateWorkspaceConnectionConfig<TName, TAI>, "name" | "host" | "ai"> {
}
declare class Workspace<TName extends WorkspaceSchema["name"], TAI extends AnyAI | undefined> extends APIManager {
    private _ai;
    id: WorkspaceSchema["workspaceID"];
    groupID: WorkspaceSchema["workspaceGroupID"];
    name: TName;
    endpoint: WorkspaceSchema["endpoint"];
    size: WorkspaceSchema["size"];
    state: WorkspaceSchema["state"];
    scaleFactor: WorkspaceSchema["scaleFactor"];
    scalingProgress: WorkspaceSchema["scalingProgress"];
    cacheConfig: WorkspaceSchema["cacheConfig"];
    kaiEnabled: WorkspaceSchema["kaiEnabled"];
    deploymentType: WorkspaceSchema["deploymentType"];
    createdAt: Date;
    lastResumedAt: Date | undefined;
    terminatedAt: Date | undefined;
    autoSuspend: WorkspaceAutoSuspend | undefined;
    resumeAttachments: WorkspaceResumeAttachment[] | undefined;
    protected _baseURL: string;
    privateConnection: WorkspacePrivateConnectionManager;
    constructor(api: API, _ai: TAI, id: WorkspaceSchema["workspaceID"], groupID: WorkspaceSchema["workspaceGroupID"], name: TName, endpoint: WorkspaceSchema["endpoint"], size: WorkspaceSchema["size"], state: WorkspaceSchema["state"], scaleFactor: WorkspaceSchema["scaleFactor"], scalingProgress: WorkspaceSchema["scalingProgress"], cacheConfig: WorkspaceSchema["cacheConfig"], kaiEnabled: WorkspaceSchema["kaiEnabled"], deploymentType: WorkspaceSchema["deploymentType"], createdAt: Date, lastResumedAt: Date | undefined, terminatedAt: Date | undefined, autoSuspend: WorkspaceAutoSuspend | undefined, resumeAttachments: WorkspaceResumeAttachment[] | undefined);
    static getBaseURL(id: WorkspaceSchema["workspaceID"]): string;
    static update(api: API, id: WorkspaceSchema["workspaceID"], body: UpdateWorkspaceBody): Promise<WorkspaceSchema["workspaceID"]>;
    static delete(api: API, id: WorkspaceSchema["workspaceID"]): Promise<WorkspaceSchema["workspaceID"]>;
    static resume(api: API, id: WorkspaceSchema["workspaceID"], body?: ResumeWorkspaceBody): Promise<WorkspaceSchema["workspaceID"]>;
    static suspend(api: API, id: WorkspaceSchema["workspaceID"]): Promise<WorkspaceSchema["workspaceID"]>;
    static getState(api: API, id: WorkspaceSchema["workspaceID"]): Promise<WorkspaceSchema["state"]>;
    connect(config: ConnectWorkspaceConfig<TName, TAI>): WorkspaceConnection<TName, TAI>;
    update(body: UpdateWorkspaceBody): Promise<string>;
    delete(): Promise<string>;
    resume(body?: ResumeWorkspaceBody): Promise<string>;
    suspend(): Promise<string>;
    getState(): Promise<"PENDING" | "ACTIVE" | "SUSPENDED" | "FAILED" | "TERMINATED">;
}

interface CreateWorkspaceConnectionConfig<TName extends WorkspaceSchema["name"] | undefined, TAI extends AnyAI | undefined> extends ConnectionConfig$1 {
    name?: TName;
    ai?: TAI;
}
declare class WorkspaceConnection<TName extends WorkspaceSchema["name"] | undefined, TAI extends AnyAI | undefined> extends Connection {
    name: TName;
    private _ai;
    database: DatabaseManager<TName, TAI>;
    constructor({ name, ai, ...config }: CreateWorkspaceConnectionConfig<TName, TAI>);
    static create<TName extends WorkspaceSchema["name"] | undefined, TAI extends AnyAI | undefined>(config: CreateWorkspaceConnectionConfig<TName, TAI>): WorkspaceConnection<TName, TAI>;
}

interface OrganizationSchema {
    orgID: string;
    name: string;
}
interface Organization extends Omit<OrganizationSchema, "orgID"> {
    id: string;
}

declare class OrganizationManager extends APIManager {
    protected _baseURL: string;
    get(): Promise<Organization>;
}

type RegionProvider = "AWS" | "GCP" | "Azure";
type RegionName = "US West 2 (Oregon)" | "US East 1 (N. Virginia)" | "Europe West 1 (Ireland)" | "Europe Central 1 (Frankfurt)" | "US East 1 (N. Virginia) - HD2" | "Asia Pacific Northeast 2 (Seoul)" | "Asia Pacific Southeast 1 (Singapore)" | "Asia Pacific Southeast 3 (Jakarta)" | "Europe West 2 (London)" | "Middle East 1 (UAE)" | "Asia Pacific Southeast 2 (Sydney)" | "US East 2 (Ohio)" | "Europe West 3 (Paris)" | "Canada Central 1 (Montreal)" | "Africa South 1 (Cape Town)" | "South America East 1 (Sao Paulo)" | "Asia Pacific South 1 (Mumbai)" | "Europe North 1 (Stockholm)";
interface RegionSchema {
    regionID: string;
    region: RegionName;
    provider: RegionProvider;
}
interface Region extends Omit<RegionSchema, "regionID" | "region"> {
    id: string;
    name: RegionName;
}

declare class RegionManager extends APIManager {
    protected _baseURL: string;
    get<T extends {
        id: RegionSchema["regionID"];
    } | {
        name: RegionSchema["region"];
    } | undefined = undefined, _ReturnType = T extends {
        id: RegionSchema["regionID"];
    } | {
        name: RegionSchema["region"];
    } ? Region | undefined : Region[]>(where?: T): Promise<_ReturnType>;
}

type WorkspaceGroupStageContent = string | any[];
interface WorkspaceGroupStageSchema {
    name: string;
    content: WorkspaceGroupStageContent;
    type: "json" | "directory" | null;
    path: string;
    format: string | null;
    mimetype: string | null;
    size: number;
    writable: boolean;
    created: string;
    last_modified: string;
}
interface UpdateWorkspaceGroupStageBody {
    newPath?: WorkspaceGroupStageSchema["path"];
}
declare class WorkspaceGroupStage extends APIManager {
    private _workspaceGroupID;
    name: WorkspaceGroupStageSchema["name"];
    content: WorkspaceGroupStageSchema["content"];
    type: WorkspaceGroupStageSchema["type"];
    path: WorkspaceGroupStageSchema["path"];
    format: WorkspaceGroupStageSchema["format"];
    mimetype: WorkspaceGroupStageSchema["mimetype"];
    size: WorkspaceGroupStageSchema["size"];
    writable: WorkspaceGroupStageSchema["writable"];
    createdAt: Date | undefined;
    modifiedAt: Date | undefined;
    protected _baseURL: string;
    constructor(api: API, _workspaceGroupID: WorkspaceGroupSchema["workspaceGroupID"], name: WorkspaceGroupStageSchema["name"], content: WorkspaceGroupStageSchema["content"], type: WorkspaceGroupStageSchema["type"], path: WorkspaceGroupStageSchema["path"], format: WorkspaceGroupStageSchema["format"], mimetype: WorkspaceGroupStageSchema["mimetype"], size: WorkspaceGroupStageSchema["size"], writable: WorkspaceGroupStageSchema["writable"], createdAt: Date | undefined, modifiedAt: Date | undefined);
    static getBaseURL(workspaceGroupID: WorkspaceGroupSchema["workspaceGroupID"], path: WorkspaceGroupStageSchema["path"]): string;
    static serializePath(path?: WorkspaceGroupStageSchema["path"]): string;
    static formatPath(id: WorkspaceGroupSchema["workspaceGroupID"], path?: WorkspaceGroupStageSchema["path"]): string;
    static mergePaths(...paths: (string | undefined)[]): string;
    static get(api: API, id: WorkspaceGroupSchema["workspaceGroupID"], path?: WorkspaceGroupStageSchema["path"]): Promise<WorkspaceGroupStage>;
    static update(api: API, id: WorkspaceGroupSchema["workspaceGroupID"], path: WorkspaceGroupStageSchema["path"], body: UpdateWorkspaceGroupStageBody): Promise<Pick<WorkspaceGroupStage, "name" | "path">>;
    static delete(api: API, id: WorkspaceGroupSchema["workspaceGroupID"], path: WorkspaceGroupStage["path"]): Promise<Pick<WorkspaceGroupStage, "name" | "path">>;
    static createFolder(api: API, id: WorkspaceGroupSchema["workspaceGroupID"], path: WorkspaceGroupStage["path"], name: string): Promise<WorkspaceGroupStage>;
    static uploadFile(api: API, id: WorkspaceGroupSchema["workspaceGroupID"], path: WorkspaceGroupStage["path"], file: File): Promise<void>;
    get(path?: WorkspaceGroupStage["path"]): Promise<WorkspaceGroupStage>;
    update(body: UpdateWorkspaceGroupStageBody, path?: WorkspaceGroupStage["path"]): Promise<Pick<WorkspaceGroupStage, "name" | "path">>;
    delete(path?: WorkspaceGroupStage["path"]): Promise<Pick<WorkspaceGroupStage, "name" | "path">>;
    createFolder(name: string, path?: WorkspaceGroupStage["path"]): Promise<WorkspaceGroupStage>;
    uploadFile(file: File, path?: WorkspaceGroupStage["path"]): Promise<void>;
}

declare class WorkspaceGroupStageManager extends APIManager {
    private _workspaceGroupID;
    protected _baseURL: string;
    constructor(api: API, _workspaceGroupID: WorkspaceGroupSchema["workspaceGroupID"]);
    static getBaseURL(workspaceGroupID: WorkspaceGroupSchema["workspaceGroupID"]): string;
    get(...args: Parameters<typeof WorkspaceGroupStage.get> extends [any, any, ...infer Rest] ? Rest : never): Promise<WorkspaceGroupStage>;
    update(...args: Parameters<typeof WorkspaceGroupStage.update> extends [any, any, ...infer Rest] ? Rest : never): Promise<Pick<WorkspaceGroupStage, "name" | "path">>;
    delete(...args: Parameters<typeof WorkspaceGroupStage.delete> extends [any, any, ...infer Rest] ? Rest : never): Promise<Pick<WorkspaceGroupStage, "name" | "path">>;
    createFolder(...args: Parameters<typeof WorkspaceGroupStage.createFolder> extends [any, any, ...infer Rest] ? Rest : never): Promise<WorkspaceGroupStage>;
}

interface ReplicatedDatabaseSchema {
    region: RegionName;
    databaseName: string;
    duplicationState: "Pending" | "Active" | "Inactive" | "Error";
}
interface StorageDRStatusSchema {
    compute: {
        storageDRType: "Failover" | "Failback" | "PreProvisionStart" | "PreProvisionStop";
        storageDRState: "Active" | "Completed" | "Failed" | "Expired" | "Canceled";
        completedAttachments: number;
        completedWorkspaces: number;
        totalAttachments: number;
        totalWorkspaces: number;
    };
    storage: ReplicatedDatabaseSchema[];
}
declare class WorkspaceGroupStorageManager extends APIManager {
    private _workspaceGroupID;
    protected _baseURL: string;
    constructor(api: API, _workspaceGroupID: WorkspaceGroupSchema["workspaceGroupID"]);
    static getBaseURL(workspaceGroupID: WorkspaceGroupSchema["workspaceGroupID"]): string;
    getStatus(): Promise<StorageDRStatusSchema>;
    getRegions(): Promise<Region[]>;
}

interface WorkspaceGroupUpdateWindowSchema {
    day: number;
    hour: number;
}
interface WorkspaceGroupUpdateWindow extends Omit<WorkspaceGroupUpdateWindowSchema, "day"> {
    day: "mo" | "tu" | "we" | "th" | "fr" | "sa" | "su";
}
interface WorkspaceGroupSchema {
    workspaceGroupID: string;
    name: string;
    regionID: string;
    state: "ACTIVE" | "PENDING" | "FAILED" | "TERMINATED";
    smartDRStatus: "ACTIVE" | "STANDBY" | undefined;
    allowAllTraffic: boolean | undefined;
    firewallRanges: string[];
    updateWindow: WorkspaceGroupUpdateWindowSchema;
    createdAt: string;
    expiresAt: string | undefined;
    terminatedAt: string | undefined;
}
interface UpdateWorkspaceGroupBody extends Partial<Pick<WorkspaceGroupSchema, "name" | "allowAllTraffic" | "firewallRanges">> {
    expiresAt?: Date;
    adminPassword?: string;
    updateWindow?: WorkspaceGroupUpdateWindow;
}
declare const updateWindowDaysMap: Record<number, WorkspaceGroupUpdateWindow["day"]>;
declare class WorkspaceGroup<TAI extends AnyAI | undefined> extends APIManager {
    private _ai;
    private _organization;
    id: WorkspaceGroupSchema["workspaceGroupID"];
    name: WorkspaceGroupSchema["name"];
    regionID: WorkspaceGroupSchema["regionID"];
    state: WorkspaceGroupSchema["state"];
    smartDRStatus: WorkspaceGroupSchema["smartDRStatus"];
    allowAllTraffic: WorkspaceGroupSchema["allowAllTraffic"];
    firewallRanges: WorkspaceGroupSchema["firewallRanges"];
    updateWindow: WorkspaceGroupUpdateWindow | undefined;
    createdAt: Date;
    expiresAt: Date | undefined;
    terminatedAt: Date | undefined;
    protected _baseURL: string;
    stage: WorkspaceGroupStageManager;
    storage: WorkspaceGroupStorageManager;
    workspace: WorkspaceManager<TAI>;
    constructor(api: API, _ai: TAI, _organization: OrganizationManager, id: WorkspaceGroupSchema["workspaceGroupID"], name: WorkspaceGroupSchema["name"], regionID: WorkspaceGroupSchema["regionID"], state: WorkspaceGroupSchema["state"], smartDRStatus: WorkspaceGroupSchema["smartDRStatus"], allowAllTraffic: WorkspaceGroupSchema["allowAllTraffic"], firewallRanges: WorkspaceGroupSchema["firewallRanges"], updateWindow: WorkspaceGroupUpdateWindow | undefined, createdAt: Date, expiresAt: Date | undefined, terminatedAt: Date | undefined);
    static getBaseURL(id: WorkspaceGroupSchema["workspaceGroupID"]): string;
    static serializeUpdateWindow(updateWindow: WorkspaceGroupUpdateWindow): WorkspaceGroupUpdateWindowSchema;
    static update(api: API, id: WorkspaceGroupSchema["workspaceGroupID"], body: UpdateWorkspaceGroupBody): Promise<WorkspaceGroupSchema["workspaceGroupID"]>;
    static delete(api: API, id: WorkspaceGroupSchema["workspaceGroupID"], force?: boolean): Promise<WorkspaceGroupSchema["workspaceGroupID"]>;
    update(...args: Parameters<typeof WorkspaceGroup.update> extends [any, any, ...infer Rest] ? Rest : never): Promise<string>;
    delete(...args: Parameters<typeof WorkspaceGroup.delete> extends [any, any, ...infer Rest] ? Rest : never): Promise<string>;
    getPrivateConnections(): Promise<PrivateConnection[]>;
    getMetrics(): Promise<string>;
}

interface CreateWorkspaceGroupBody {
    name: WorkspaceGroupSchema["name"];
    adminPassword?: string;
    allowAllTraffic?: boolean;
    firewallRanges?: string[];
    regionName: RegionName;
    updateWindow?: WorkspaceGroupUpdateWindow;
    dataBucketKMSKeyID?: string;
    backupBucketKMSKeyID?: string;
    expiresAt?: Date;
}
type GetWorkspaceGroupSelectParam = (keyof WorkspaceGroupSchema)[] | undefined;
type GetWorkspaceGroupWhereParam = {
    id: WorkspaceGroupSchema["workspaceGroupID"];
} | {
    name: WorkspaceGroupSchema["name"];
} | undefined;
interface GetWorkspaceGroupParams<TSelect extends GetWorkspaceGroupSelectParam = undefined, TWhere extends GetWorkspaceGroupWhereParam = undefined> {
    select?: TSelect;
    where?: TWhere;
    includeTerminated?: boolean;
}
type WorkspaceGroupBySelect<TSelect extends GetWorkspaceGroupSelectParam> = TSelect extends (keyof WorkspaceGroup<any>)[] ? Pick<WorkspaceGroup<any>, TSelect[number]> : WorkspaceGroup<any>;
declare class WorkspaceGroupManager<TAI extends AnyAI | undefined> extends APIManager {
    private _ai;
    private _organization;
    private _region;
    protected _baseURL: string;
    constructor(_api: API, _ai: TAI, _organization: OrganizationManager, _region: RegionManager);
    private _create;
    create({ regionName, firewallRanges, ...body }: CreateWorkspaceGroupBody): Promise<{
        workspaceGroup: WorkspaceGroup<TAI>;
        adminPassword: string | undefined;
    }>;
    get<TSelect extends GetWorkspaceGroupSelectParam = undefined, TWhere extends GetWorkspaceGroupWhereParam = undefined, _TReturnType = TWhere extends {
        id: WorkspaceGroupSchema["workspaceGroupID"];
    } ? WorkspaceGroupBySelect<TSelect> | undefined : WorkspaceGroupBySelect<TSelect>[]>({ where, select, includeTerminated }?: GetWorkspaceGroupParams<TSelect, TWhere>): Promise<_TReturnType>;
    update(...args: Tail<Parameters<typeof WorkspaceGroup.update>>): Promise<string>;
    delete(...args: Tail<Parameters<typeof WorkspaceGroup.delete>>): Promise<string>;
}

interface CreateWorkspaceBody extends Pick<WorkspaceSchema, "name">, Partial<Pick<WorkspaceSchema, "cacheConfig" | "scaleFactor" | "size">>, Pick<UpdateWorkspaceBody, "enableKai" | "autoSuspend"> {
}
type GetWorkspaceSelectParam = (keyof WorkspaceSchema)[] | undefined;
type GetWorkspaceWhereParam = {
    id: WorkspaceSchema["workspaceID"];
} | {
    name: WorkspaceSchema["name"];
} | undefined;
interface GetWorkspaceParams<TSelect extends GetWorkspaceSelectParam = undefined, TWhere extends GetWorkspaceWhereParam = undefined> {
    select?: TSelect;
    where?: TWhere;
    includeTerminated?: boolean;
}
type WorkspaceBySelect<TSelect extends GetWorkspaceSelectParam> = TSelect extends (keyof Workspace<any, any>)[] ? Pick<Workspace<any, any>, TSelect[number]> : Workspace<any, any>;
declare class WorkspaceManager<TAI extends AnyAI | undefined> extends APIManager {
    private _ai;
    private _workspaceGroupID;
    protected _baseURL: string;
    constructor(api: API, _ai: TAI, _workspaceGroupID: WorkspaceGroupSchema["workspaceGroupID"]);
    private _create;
    create(body: CreateWorkspaceBody): Promise<Workspace<any, any> | undefined>;
    get<TSelect extends GetWorkspaceSelectParam = undefined, TWhere extends GetWorkspaceWhereParam = undefined, _TReturnType = TWhere extends {
        id: WorkspaceSchema["workspaceID"];
    } ? WorkspaceBySelect<TSelect> | undefined : WorkspaceBySelect<TSelect>[]>({ where, select, includeTerminated }?: GetWorkspaceParams<TSelect, TWhere>): Promise<_TReturnType>;
    update(...args: Tail<Parameters<typeof Workspace.update>>): Promise<string>;
    delete(...args: Tail<Parameters<typeof Workspace.delete>>): Promise<string>;
    resume(...args: Tail<Parameters<typeof Workspace.resume>>): Promise<string>;
    suspend(...args: Tail<Parameters<typeof Workspace.suspend>>): Promise<string>;
    getState(...args: Tail<Parameters<typeof Workspace.getState>>): Promise<"PENDING" | "ACTIVE" | "SUSPENDED" | "FAILED" | "TERMINATED">;
}

type DatabaseName = string;
interface DatabaseType {
    name: DatabaseName;
    tables: Record<PropertyKey, TableType>;
}
interface DatabaseSchema<TType extends DatabaseType> {
    name: TType["name"];
    tables?: {
        [K in keyof TType["tables"]]: Omit<CreateTableSchema<Extract<K, string>, TType["tables"][K]>, "name">;
    };
}
interface DatabaseInfo<TType extends DatabaseType> {
    name: TType["name"];
}
interface DatabaseInfoExtended<TType extends DatabaseType> extends DatabaseInfo<TType> {
    commits: number;
    role: string;
    state: string;
    position: string;
    details: string;
    asyncSlaves: number;
    syncSlaves: string;
    consensusSlaves: number;
    committedPosition: string;
    hardenedPosition: string;
    replayPosition: string;
    term: number;
    lastPageTerm: number;
    memoryMBs: number;
    pendingIOs: number;
    pendingBlobFSyncs: number;
}
type DatabaseTableName<TType extends DatabaseType> = Extract<keyof TType["tables"], string>;
type InferDatabaseType<T> = T extends Database<infer TType, any, any> ? TType : never;
type DatabaseTablesToRecords<TTables extends DatabaseType["tables"]> = {
    [K in keyof TTables]: TTables[K][];
};
type AnyDatabase = Database<any, any, any>;
declare class Database<TType extends DatabaseType, TWorkspaceName extends WorkspaceSchema["name"] | undefined, TAI extends AnyAI | undefined> {
    private _client;
    private _ai;
    name: TType["name"];
    workspaceName: TWorkspaceName;
    table: TableManager<TType, TAI>;
    constructor(_client: ConnectionClient, _ai: TAI, name: TType["name"], workspaceName: TWorkspaceName);
    static drop<TName extends DatabaseName>(client: ConnectionClient, name: TName): Promise<[ResultSetHeader, mysql2_promise.FieldPacket[]]>;
    static normalizeInfo<TType extends DatabaseType, TExtended extends boolean, _ReturnType = TExtended extends true ? DatabaseInfoExtended<TType> : DatabaseInfo<TType>>(info: any, extended?: TExtended): _ReturnType;
    drop(...args: Parameters<typeof Database.drop> extends [any, any, ...infer Rest] ? Rest : never): Promise<[ResultSetHeader, mysql2_promise.FieldPacket[]]>;
    showInfo<TExtended extends boolean = false>(extended?: TExtended): Promise<TExtended extends true ? DatabaseInfoExtended<TType> : DatabaseInfo<TType>>;
    showTablesInfo<TExtended extends boolean = false>(extended?: TExtended): Promise<(TExtended extends true ? TableInfoExtended<Extract<keyof TType["tables"], string>> : TableInfo<Extract<keyof TType["tables"], string>>)[]>;
    describe(): Promise<{
        tables: {
            columns: ColumnInfo<Extract<keyof (Extract<keyof TType["tables"], string> extends infer T ? T extends Extract<keyof TType["tables"], string> ? T extends Extract<keyof TType["tables"], string> ? TType["tables"][T] : TableType : never : never), string>>[];
            tableType: string;
            distributed: boolean;
            storageType: string;
            name: Extract<keyof TType["tables"], string>;
        }[];
        commits: number;
        role: string;
        state: string;
        position: string;
        details: string;
        asyncSlaves: number;
        syncSlaves: string;
        consensusSlaves: number;
        committedPosition: string;
        hardenedPosition: string;
        replayPosition: string;
        term: number;
        lastPageTerm: number;
        memoryMBs: number;
        pendingIOs: number;
        pendingBlobFSyncs: number;
        name: TType["name"];
    }>;
    query<TReturnType extends any[]>(statement: string): Promise<TReturnType[]>;
}

declare class DatabaseManager<TWorkspaceName extends WorkspaceSchema["name"] | undefined, TAI extends AnyAI | undefined> {
    private _client;
    private _ai;
    workspaceName: TWorkspaceName;
    constructor(_client: ConnectionClient, _ai: TAI, workspaceName: TWorkspaceName);
    use<TType extends DatabaseType>(name: TType["name"]): Database<TType, TWorkspaceName, TAI>;
    create<TType extends DatabaseType>(schema: DatabaseSchema<TType>): Promise<Database<TType, TWorkspaceName, TAI>>;
    drop(...args: Tail<Parameters<typeof Database.drop>>): Promise<[ResultSetHeader, mysql2_promise.FieldPacket[]]>;
}

type BillingMetric = "ComputeCredit" | "StorageAvgByte";
interface BillingUsageSchema {
    resourceID: string;
    resourceName: string;
    resourceType: string;
    startTime: string;
    endTime: string;
    value: string;
}
interface StorageAvgByteBillingUsageSchema extends BillingUsageSchema {
}
interface StorageAvgByteBillingUsage extends Omit<StorageAvgByteBillingUsageSchema, "startTime" | "endTime"> {
    startTime: Date;
    endTime: Date;
}
interface ComputeCreditBillingUsageSchema extends BillingUsageSchema {
    ownerID: string | null | undefined;
}
interface ComputeCreditBillingUsage extends Omit<ComputeCreditBillingUsageSchema, "startTime" | "endTime"> {
    startTime: Date;
    endTime: Date;
}
interface BillingSchema<T extends BillingMetric> {
    metric: T;
    description: string;
    Usage: (T extends "ComputeCredit" ? ComputeCreditBillingUsageSchema : StorageAvgByteBillingUsageSchema)[];
}
interface Billing<TMetric extends BillingMetric, TUsage extends StorageAvgByteBillingUsage | ComputeCreditBillingUsage> {
    metric: TMetric;
    description: string;
    usage: TUsage[];
}
interface StorageAvgByteBilling extends Billing<"StorageAvgByte", StorageAvgByteBillingUsage> {
}
interface ComputeCreditBilling extends Billing<"ComputeCredit", ComputeCreditBillingUsage> {
}

interface GetBillingParams {
    metric: BillingMetric;
    startTime: Date;
    endTime: Date;
    aggregateBy?: "hour" | "day" | "month";
}
declare class BillingManager extends APIManager {
    protected _baseURL: string;
    get<T extends GetBillingParams, _TReturnType = T["metric"] extends "ComputeCredit" ? ComputeCreditBilling[] : StorageAvgByteBilling[]>({ metric, startTime, endTime, aggregateBy }: T): Promise<_TReturnType>;
}

interface JobRuntime {
    name: "notebooks-cpu-small" | "notebooks-cpu-medium" | "notebooks-gpu-t4";
    description: string;
}
interface JobMetadata {
    count: number;
    avgDurationInSeconds: number | null;
    maxDurationInSeconds: number | null;
    status: "Unknown" | "Scheduled" | "Running" | "Completed" | "Failed" | "Error" | "Canceled";
}
interface JobScheduleSchema {
    mode: "Recurring" | "Once";
    startAt: string | null;
    executionIntervalInMinutes: number | null;
}
interface JobSchedule extends Omit<JobScheduleSchema, "startAt"> {
    startAt: Date | null;
}
interface JobTargetConfig {
    targetID: string;
    targetType: "Workspace" | "Cluster" | "VirtualWorkspace";
    resumeTarget: boolean;
    databaseName: string;
}
interface JobExecutionConfig {
    notebookPath: string;
    createSnapshot: boolean;
    maxAllowedExecutionDurationInMinutes: number;
}
interface JobSchema {
    jobID: string;
    name: string;
    description: string | null;
    enqueuedBy: string;
    jobMetadata: JobMetadata[];
    schedule: JobScheduleSchema;
    targetConfig: JobTargetConfig;
    executionConfig: JobExecutionConfig;
    completedExecutionsCount: number;
    createdAt: string;
    terminatedAt: string | null;
}
interface JobParameter {
    type: "string" | "integer" | "float" | "boolean";
    name: string;
    value: string;
}
interface JobExecutionSchema {
    id: string;
    number: number;
    jobID: string;
    scheduledStartTime: string;
    startedAt: string | null;
    finishedAt: string | null;
    snapshotNotebookPath: string | null;
    status: "Scheduled" | "Running" | "Completed" | "Failed";
}
interface JobExecution extends Omit<JobExecutionSchema, "scheduledStartTime" | "startedAt" | "finishedAt"> {
    scheduledStartTime: Date;
    startedAt: Date | null;
    finishedAt: Date | null;
}
declare class Job extends APIManager {
    id: JobSchema["jobID"];
    name: JobSchema["name"];
    description: JobSchema["description"];
    enqueuedBy: JobSchema["enqueuedBy"];
    executionConfig: JobSchema["executionConfig"];
    metadata: JobSchema["jobMetadata"];
    targetConfig: JobSchema["targetConfig"];
    completedExecutionsCount: JobSchema["completedExecutionsCount"];
    schedule: JobSchedule;
    createdAt: Date;
    terminatedAt: Date | null;
    protected _baseURL: string;
    constructor(_api: API, id: JobSchema["jobID"], name: JobSchema["name"], description: JobSchema["description"], enqueuedBy: JobSchema["enqueuedBy"], executionConfig: JobSchema["executionConfig"], metadata: JobSchema["jobMetadata"], targetConfig: JobSchema["targetConfig"], completedExecutionsCount: JobSchema["completedExecutionsCount"], schedule: JobSchedule, createdAt: Date, terminatedAt: Date | null);
    static getBaseURL(id: JobSchema["jobID"]): string;
    static delete(api: API, id: JobSchema["jobID"]): Promise<boolean>;
    static getExecutions(api: API, id: JobSchema["jobID"], start: number, end: number): Promise<JobExecution[]>;
    static getParameters(api: API, id: JobSchema["jobID"]): Promise<JobParameter[]>;
    delete(): Promise<boolean>;
    getExecutions(start: number, end: number): Promise<JobExecution[]>;
    getParameters(): Promise<JobParameter[]>;
}

interface CreateJobBody {
    name?: JobSchema["name"];
    description?: JobSchema["description"];
    executionConfig: {
        runtimeName?: string;
        notebookPath: string;
        createSnapshot?: boolean;
    };
    parameters?: JobParameter[];
    schedule: Optional<JobSchedule, "executionIntervalInMinutes" | "startAt">;
    targetConfig?: Optional<JobTargetConfig, "databaseName" | "resumeTarget">;
}
declare class JobManager extends APIManager {
    protected _baseURL: string;
    private _create;
    create(body: CreateJobBody): Promise<Job>;
    get(id: JobSchema["jobID"]): Promise<Job>;
    delete(...args: Tail<Parameters<typeof Job.delete>>): Promise<boolean>;
    getExecutions(...args: Tail<Parameters<typeof Job.getExecutions>>): Promise<JobExecution[]>;
    getParameters(...args: Tail<Parameters<typeof Job.getParameters>>): Promise<JobParameter[]>;
    getRuntimes(): Promise<JobRuntime[]>;
}

interface SecretSchema {
    secretID: string;
    name: string;
    value: string | undefined;
    lastUpdatedBy: string;
    lastUpdatedAt: string;
    createdBy: string;
    createdAt: string;
}
declare class Secret extends APIManager {
    id: SecretSchema["secretID"];
    name: SecretSchema["name"];
    value: SecretSchema["value"];
    lastUpdatedBy: SecretSchema["lastUpdatedBy"];
    lastUpdatedAt: Date;
    createdBy: SecretSchema["createdBy"];
    createdAt: Date;
    protected _baseURL: string;
    constructor(api: API, id: SecretSchema["secretID"], name: SecretSchema["name"], value: SecretSchema["value"], lastUpdatedBy: SecretSchema["lastUpdatedBy"], lastUpdatedAt: Date, createdBy: SecretSchema["createdBy"], createdAt: Date);
    static getBaseURL(id: SecretSchema["secretID"]): string;
    static update(api: API, id: SecretSchema["secretID"], value: Defined<SecretSchema["value"]>): Promise<Secret>;
    static delete(api: API, id: SecretSchema["secretID"]): Promise<SecretSchema["secretID"]>;
    update(value: Defined<SecretSchema["value"]>): Promise<Secret>;
    delete(): Promise<string>;
}

interface CreateSecretBody {
    name: SecretSchema["name"];
    value: Defined<SecretSchema["value"]>;
}
declare class SecretManager extends APIManager {
    protected _baseURL: string;
    private _create;
    create(body: CreateSecretBody): Promise<Secret>;
    get<T extends {
        id: SecretSchema["secretID"];
    } | {
        name: SecretSchema["name"];
    } | undefined = undefined, _TReturnType = T extends undefined ? Secret[] : Secret | undefined>(where?: T): Promise<_TReturnType>;
    update(...args: Tail<Parameters<typeof Secret.update>>): Promise<Secret>;
    delete(...args: Tail<Parameters<typeof Secret.delete>>): Promise<string>;
}

interface TeamMemberTeamSchema {
    teamID: string;
    name: string;
    description: string;
}
interface TeamMemberTeam extends Omit<TeamMemberTeamSchema, "teamID"> {
    id: string;
}
interface TeamMemberUserSchema {
    userID: string;
    firstName: string;
    lastName: string;
    email: string;
}
interface TeamMemberUser extends Omit<TeamMemberUserSchema, "userID"> {
    id: string;
}
interface TeamSchema {
    teamID: string;
    name: string;
    description: string;
    memberTeams: TeamMemberTeamSchema[] | undefined;
    memberUsers: TeamMemberUserSchema[] | undefined;
    createdAt: string;
}
interface UpdateTeamBody extends Partial<Pick<TeamSchema, "name" | "description">> {
}
declare class Team extends APIManager {
    id: TeamSchema["teamID"];
    name: TeamSchema["name"];
    description: TeamSchema["description"];
    memberTeams: TeamMemberTeam[] | undefined;
    memberUsers: TeamMemberUser[] | undefined;
    createdAt: Date;
    protected _baseURL: string;
    constructor(api: API, id: TeamSchema["teamID"], name: TeamSchema["name"], description: TeamSchema["description"], memberTeams: TeamMemberTeam[] | undefined, memberUsers: TeamMemberUser[] | undefined, createdAt: Date);
    static getBaseURL(id: TeamSchema["teamID"]): string;
    static update(api: API, id: TeamSchema["teamID"], body: UpdateTeamBody): Promise<TeamSchema["teamID"]>;
    static delete(api: API, id: TeamSchema["teamID"]): Promise<TeamSchema["teamID"]>;
    static addMemberTeams(api: API, id: TeamSchema["teamID"], teamIDs: TeamMemberTeamSchema["teamID"][]): Promise<TeamSchema["teamID"]>;
    static removeMemberTeams(api: API, id: TeamSchema["teamID"], teamIDs: TeamMemberTeamSchema["teamID"][]): Promise<TeamSchema["teamID"]>;
    static addMemberUsers(api: API, id: TeamSchema["teamID"], userIDs: TeamMemberUserSchema["userID"][]): Promise<TeamSchema["teamID"]>;
    static removeMemberUsers(api: API, id: TeamSchema["teamID"], userIDs: TeamMemberUserSchema["userID"][]): Promise<TeamSchema["teamID"]>;
    update(body: UpdateTeamBody): Promise<string>;
    delete(): Promise<string>;
    addMemberTeams(teamIDs: TeamMemberTeamSchema["teamID"][]): Promise<string>;
    removeMemberTeams(teamIDs: TeamMemberTeamSchema["teamID"][]): Promise<string>;
    addMemberUsers(userIDs: TeamMemberUserSchema["userID"][]): Promise<string>;
    removeMemberUsers(userIDs: TeamMemberUserSchema["userID"][]): Promise<string>;
}

interface CreateTeamBody {
    name: TeamSchema["name"];
    description?: TeamSchema["description"];
    memberTeams?: TeamMemberTeamSchema["teamID"][];
    memberUsers?: TeamMemberUserSchema["userID"][];
}
declare class TeamManager extends APIManager {
    protected _baseURL: string;
    private _create;
    create({ memberTeams, memberUsers, ...body }: CreateTeamBody): Promise<Team>;
    get<T extends {
        id: TeamSchema["teamID"];
    } | {
        name: TeamSchema["name"];
    } | {
        description: TeamSchema["description"];
    } | undefined = undefined, _TReturnType = T extends undefined ? Team[] : Team | undefined>(where?: T): Promise<_TReturnType>;
    update(...args: Parameters<typeof Team.update> extends [any, ...infer Rest] ? Rest : never): Promise<string>;
    delete(...args: Tail<Parameters<typeof Team.delete>>): Promise<string>;
    addMemberTeams(...args: Tail<Parameters<typeof Team.addMemberTeams>>): Promise<string>;
    removeMemberTeams(...args: Tail<Parameters<typeof Team.removeMemberTeams>>): Promise<string>;
    addMemberUsers(...args: Tail<Parameters<typeof Team.addMemberUsers>>): Promise<string>;
    removeMemberUsers(...args: Tail<Parameters<typeof Team.removeMemberUsers>>): Promise<string>;
}

interface ClientConfig<TAI extends AnyAI | undefined = undefined> {
    ai?: TAI;
    apiKey?: string;
}
interface ConnectionConfig<TName extends WorkspaceSchema["name"] | undefined = undefined, TAI extends AnyAI | undefined = undefined> extends Omit<CreateWorkspaceConnectionConfig<TName, TAI>, "ai"> {
}
declare class SingleStoreClient<TAI extends AnyAI | undefined = undefined> {
    private _ai;
    private _api;
    billing: BillingManager;
    job: JobManager;
    organization: OrganizationManager;
    region: RegionManager;
    secret: SecretManager;
    team: TeamManager;
    workspaceGroup: WorkspaceGroupManager<TAI>;
    constructor(config?: ClientConfig<TAI>);
    connect<TName extends WorkspaceSchema["name"] | undefined = undefined>(config: ConnectionConfig<TName, TAI>): WorkspaceConnection<TName, TAI>;
}

export { API, APIManager, type APIVersion, type AddColumnSchema, type AnyDatabase, type AnyQueryBuilderParams, type Billing, BillingManager, type BillingMetric, type BillingSchema, type BillingUsageSchema, type ClientConfig, Column, type ColumnInfo, ColumnManager, type ColumnName, type ColumnSchema, type ColumnType, type ComputeCreditBilling, type ComputeCreditBillingUsage, type ComputeCreditBillingUsageSchema, type ConnectWorkspaceConfig, Connection, type ConnectionClient, type ConnectionConfig, type CreateJobBody, type CreateSecretBody, type CreateTableSchema, type CreateTeamBody, type CreateWorkspaceConnectionConfig, type CreateWorkspaceGroupBody, Database, type DatabaseInfo, type DatabaseInfoExtended, DatabaseManager, type DatabaseName, type DatabaseSchema, type DatabaseTableName, type DatabaseTablesToRecords, type DatabaseType, type ExtractJoinClauseColumns, type ExtractSelectedQueryColumns, type GetBillingParams, type GetWorkspaceGroupParams, type GetWorkspaceGroupSelectParam, type GetWorkspaceGroupWhereParam, type GetWorkspaceParams, type GetWorkspacePrivateConnectionParams, type GetWorkspaceSelectParam, type GetWorkspaceWhereParam, type GroupByClause, type InferDatabaseType, Job, type JobExecution, type JobExecutionConfig, type JobExecutionSchema, JobManager, type JobMetadata, type JobParameter, type JobRuntime, type JobSchedule, type JobScheduleSchema, type JobSchema, type JobTargetConfig, type JoinClause, type OrderByClause, type OrderByDirection, type Organization, OrganizationManager, type OrganizationSchema, type PrivateConnection, type PrivateConnectionSchema, QueryBuilder, type QueryBuilderParams, type Region, RegionManager, type RegionName, type RegionProvider, type RegionSchema, type ReplicatedDatabaseSchema, type ResumeWorkspaceBody, Secret, SecretManager, type SecretSchema, type SelectClause, SingleStoreClient, type StorageAvgByteBilling, type StorageAvgByteBillingUsage, type StorageAvgByteBillingUsageSchema, type StorageDRStatusSchema, Table, type TableColumnName, type TableInfo, type TableInfoExtended, TableManager, type TableName, type TableSchema, type TableType, Team, TeamManager, type TeamMemberTeam, type TeamMemberTeamSchema, type TeamMemberUser, type TeamMemberUserSchema, type TeamSchema, type UpdateTeamBody, type UpdateWorkspaceBody, type UpdateWorkspaceGroupBody, type UpdateWorkspaceGroupStageBody, type VectorScoreKey, type WhereClause, type WhereOperator, Workspace, type WorkspaceAutoSuspend, type WorkspaceAutoSuspendSchema, WorkspaceConnection, WorkspaceGroup, WorkspaceGroupManager, type WorkspaceGroupSchema, WorkspaceGroupStage, type WorkspaceGroupStageContent, WorkspaceGroupStageManager, type WorkspaceGroupStageSchema, WorkspaceGroupStorageManager, type WorkspaceGroupUpdateWindow, type WorkspaceGroupUpdateWindowSchema, WorkspaceManager, WorkspacePrivateConnectionManager, type WorkspaceResumeAttachment, type WorkspaceResumeAttachmentSchema, type WorkspaceSchema, type WorkspaceSize, updateWindowDaysMap };
