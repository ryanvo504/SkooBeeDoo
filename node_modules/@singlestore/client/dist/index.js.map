{"version":3,"sources":["../src/index.ts","../src/api/api.ts","../src/api/manager.ts","../src/billing/manager.ts","../src/job/job.ts","../src/job/manager.ts","../src/organization/manager.ts","../src/region/manager.ts","../src/secret/secret.ts","../src/secret/manager.ts","../src/team/team.ts","../src/team/manager.ts","../src/connection.ts","../src/column/column.ts","../src/column/manager.ts","../src/query/builder.ts","../src/table/table.ts","../src/table/manager.ts","../src/database/database.ts","../src/database/manager.ts","../src/workspace/connection.ts","../src/workspace/private-connection/manager.ts","../src/workspace/workspace.ts","../src/workspace/manager.ts","../../utils/src/helpers.ts","../src/workspace-group/stage/stage.ts","../src/workspace-group/stage/manager.ts","../src/workspace-group/storage/manager.ts","../src/workspace-group/workspace-group.ts","../src/workspace-group/manager.ts","../src/client.ts"],"sourcesContent":["export type { RowDataPacket, ResultSetHeader, FieldPacket } from \"mysql2/promise\";\nexport { escape } from \"mysql2\";\nexport type * from \"./types\";\nexport * from \"./client\";\n","export type APIVersion = 1 | 2;\n\nexport class API {\n  private readonly _baseURL: string;\n\n  constructor(\n    private readonly _apiKey?: string,\n    private readonly _version: APIVersion = 1,\n  ) {\n    this._baseURL = `https://api.singlestore.com`;\n  }\n\n  async execute<T = any>(\n    url: string,\n    { version = this._version, ...params }: RequestInit & { version?: APIVersion } = {},\n  ): Promise<T> {\n    if (!this._apiKey) {\n      throw new Error(\n        \"The Management API key is undefined. Please generate a valid API key. For more info read: https://docs.singlestore.com/cloud/reference/management-api/#generate-an-api-key\",\n      );\n    }\n\n    const _url = `${this._baseURL}/v${version}${url}`;\n\n    const response = await fetch(_url, {\n      method: \"GET\",\n      ...params,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...params?.headers,\n        \"Authorization\": `Bearer ${this._apiKey}`,\n      },\n    });\n\n    const contentType = response.headers.get(\"content-type\");\n\n    if (contentType?.startsWith(\"text/plain\")) {\n      return response.text() as T;\n    }\n\n    return response.json() as T;\n  }\n}\n","import type { API } from \"./api\";\n\nexport abstract class APIManager {\n  protected abstract readonly _baseURL: string;\n\n  constructor(protected readonly _api: API) {}\n\n  protected _execute<T = any>(...[url, params]: Partial<Parameters<API[\"execute\"]>>) {\n    return this._api.execute<T>(`${this._baseURL}${url ?? \"\"}`, params);\n  }\n}\n","import type {\n  BillingMetric,\n  BillingSchema,\n  ComputeCreditBilling,\n  ComputeCreditBillingUsage,\n  StorageAvgByteBilling,\n  StorageAvgByteBillingUsage,\n} from \"./billing\";\n\nimport { APIManager } from \"../api/manager\";\n\nexport interface GetBillingParams {\n  metric: BillingMetric;\n  startTime: Date;\n  endTime: Date;\n  aggregateBy?: \"hour\" | \"day\" | \"month\";\n}\n\nexport class BillingManager extends APIManager {\n  protected _baseURL: string = \"/billing\";\n\n  async get<\n    T extends GetBillingParams,\n    _TReturnType = T[\"metric\"] extends \"ComputeCredit\" ? ComputeCreditBilling[] : StorageAvgByteBilling[],\n  >({ metric, startTime, endTime, aggregateBy }: T): Promise<_TReturnType> {\n    const params = new URLSearchParams({ metric });\n\n    Object.entries({ startTime, endTime }).forEach(([key, value]) => {\n      params.set(key, value.toISOString().split(\".\")[0] + \"Z\");\n    });\n\n    if (aggregateBy) {\n      params.set(\"aggregateBy\", aggregateBy);\n    }\n\n    const response = await this._execute<{ billingUsage: BillingSchema<T[\"metric\"]>[] }>(`/usage?${params.toString()}`);\n\n    return response.billingUsage.map((data) => {\n      const usage = data.Usage.map((usage) => {\n        return {\n          ...usage,\n          startTime: new Date(startTime),\n          endTime: new Date(endTime),\n        };\n      });\n\n      if (metric === \"ComputeCredit\") {\n        return {\n          metric: \"ComputeCredit\",\n          description: data.description,\n          usage: usage as unknown as ComputeCreditBillingUsage[],\n        } satisfies ComputeCreditBilling;\n      }\n\n      return {\n        metric: \"StorageAvgByte\",\n        description: data.description,\n        usage: usage as unknown as StorageAvgByteBillingUsage[],\n      } satisfies StorageAvgByteBilling;\n    }) as _TReturnType;\n  }\n}\n","import { APIManager, type API } from \"../api\";\n\nexport interface JobRuntime {\n  name: \"notebooks-cpu-small\" | \"notebooks-cpu-medium\" | \"notebooks-gpu-t4\";\n  description: string;\n}\n\nexport interface JobMetadata {\n  count: number;\n  avgDurationInSeconds: number | null;\n  maxDurationInSeconds: number | null;\n  status: \"Unknown\" | \"Scheduled\" | \"Running\" | \"Completed\" | \"Failed\" | \"Error\" | \"Canceled\";\n}\n\nexport interface JobScheduleSchema {\n  mode: \"Recurring\" | \"Once\";\n  startAt: string | null;\n  executionIntervalInMinutes: number | null;\n}\n\nexport interface JobSchedule extends Omit<JobScheduleSchema, \"startAt\"> {\n  startAt: Date | null;\n}\n\nexport interface JobTargetConfig {\n  targetID: string;\n  targetType: \"Workspace\" | \"Cluster\" | \"VirtualWorkspace\";\n  resumeTarget: boolean;\n  databaseName: string;\n}\n\nexport interface JobExecutionConfig {\n  notebookPath: string;\n  createSnapshot: boolean;\n  maxAllowedExecutionDurationInMinutes: number;\n}\n\nexport interface JobSchema {\n  jobID: string;\n  name: string;\n  description: string | null;\n  enqueuedBy: string;\n  jobMetadata: JobMetadata[];\n  schedule: JobScheduleSchema;\n  targetConfig: JobTargetConfig;\n  executionConfig: JobExecutionConfig;\n  completedExecutionsCount: number;\n  createdAt: string;\n  terminatedAt: string | null;\n}\n\nexport interface JobParameter {\n  type: \"string\" | \"integer\" | \"float\" | \"boolean\";\n  name: string;\n  value: string;\n}\n\nexport interface JobExecutionSchema {\n  id: string;\n  number: number;\n  jobID: string;\n  scheduledStartTime: string;\n  startedAt: string | null;\n  finishedAt: string | null;\n  snapshotNotebookPath: string | null;\n  status: \"Scheduled\" | \"Running\" | \"Completed\" | \"Failed\";\n}\nexport interface JobExecution extends Omit<JobExecutionSchema, \"scheduledStartTime\" | \"startedAt\" | \"finishedAt\"> {\n  scheduledStartTime: Date;\n  startedAt: Date | null;\n  finishedAt: Date | null;\n}\n\nexport class Job extends APIManager {\n  protected _baseURL: string;\n\n  constructor(\n    _api: API,\n    public id: JobSchema[\"jobID\"],\n    public name: JobSchema[\"name\"],\n    public description: JobSchema[\"description\"],\n    public enqueuedBy: JobSchema[\"enqueuedBy\"],\n    public executionConfig: JobSchema[\"executionConfig\"],\n    public metadata: JobSchema[\"jobMetadata\"],\n    public targetConfig: JobSchema[\"targetConfig\"],\n    public completedExecutionsCount: JobSchema[\"completedExecutionsCount\"],\n    public schedule: JobSchedule,\n    public createdAt: Date,\n    public terminatedAt: Date | null,\n  ) {\n    super(_api);\n    this._baseURL = Job.getBaseURL(this.id);\n  }\n\n  static getBaseURL(id: JobSchema[\"jobID\"]) {\n    return `/jobs/${id}`;\n  }\n\n  static async delete(api: API, id: JobSchema[\"jobID\"]): Promise<boolean> {\n    return api.execute<boolean>(this.getBaseURL(id), { method: \"DELETE\" });\n  }\n\n  static async getExecutions(api: API, id: JobSchema[\"jobID\"], start: number, end: number): Promise<JobExecution[]> {\n    const params = new URLSearchParams({ start: start.toString(), end: end.toString() });\n    const response = await api.execute(`${this.getBaseURL(id)}/executions?${params.toString()}`);\n    return response.executions.map((execution: any) => {\n      return {\n        id: execution.executionID,\n        number: execution.executionNumber,\n        jobID: execution.jobID,\n        scheduledStartTime: new Date(execution.scheduledStartTime),\n        startedAt: new Date(execution.startedAt),\n        finishedAt: new Date(execution.finishedAt),\n        snapshotNotebookPath: execution.snapshotNotebookPath,\n        status: execution.status,\n      } satisfies JobExecution;\n    });\n  }\n\n  static async getParameters(api: API, id: JobSchema[\"jobID\"]): Promise<JobParameter[]> {\n    return api.execute<JobParameter[]>(`${this.getBaseURL(id)}/parameters`);\n  }\n\n  async delete() {\n    return Job.delete(this._api, this.id);\n  }\n\n  async getExecutions(start: number, end: number) {\n    return Job.getExecutions(this._api, this.id, start, end);\n  }\n\n  async getParameters() {\n    return Job.getParameters(this._api, this.id);\n  }\n}\n","import type { Optional, Tail } from \"@repo/utils\";\n\nimport { APIManager } from \"../api/manager\";\n\nimport { Job, type JobParameter, type JobTargetConfig, type JobRuntime, type JobSchedule, type JobSchema } from \"./job\";\n\nexport interface CreateJobBody {\n  name?: JobSchema[\"name\"];\n  description?: JobSchema[\"description\"];\n  executionConfig: {\n    runtimeName?: string;\n    notebookPath: string;\n    createSnapshot?: boolean;\n  };\n  parameters?: JobParameter[];\n  schedule: Optional<JobSchedule, \"executionIntervalInMinutes\" | \"startAt\">;\n  targetConfig?: Optional<JobTargetConfig, \"databaseName\" | \"resumeTarget\">;\n}\n\nexport class JobManager extends APIManager {\n  protected _baseURL: string = \"/jobs\";\n\n  private _create(data: JobSchema): Job {\n    return new Job(\n      this._api,\n      data.jobID,\n      data.name,\n      data.description,\n      data.enqueuedBy,\n      data.executionConfig,\n      data.jobMetadata,\n      data.targetConfig,\n      data.completedExecutionsCount,\n      { ...data.schedule, startAt: data.schedule.startAt ? new Date(data.schedule.startAt) : null },\n      new Date(data.createdAt),\n      data.terminatedAt ? new Date(data.terminatedAt) : null,\n    );\n  }\n\n  async create(body: CreateJobBody) {\n    const response = await this._execute<JobSchema>(\"\", { method: \"POST\", body: JSON.stringify(body) });\n    return this._create(response);\n  }\n\n  async get(id: JobSchema[\"jobID\"]) {\n    const response = await this._execute<JobSchema>(`/${id}`);\n    return this._create(response);\n  }\n\n  async delete(...args: Tail<Parameters<typeof Job.delete>>) {\n    return Job.delete(this._api, ...args);\n  }\n\n  async getExecutions(...args: Tail<Parameters<typeof Job.getExecutions>>) {\n    return Job.getExecutions(this._api, ...args);\n  }\n\n  async getParameters(...args: Tail<Parameters<typeof Job.getParameters>>) {\n    return Job.getParameters(this._api, ...args);\n  }\n\n  async getRuntimes() {\n    return this._execute<JobRuntime[]>(\"/runtimes\");\n  }\n}\n","import type { Organization, OrganizationSchema } from \"./organization\";\n\nimport { APIManager } from \"../api/manager\";\n\nexport class OrganizationManager extends APIManager {\n  protected _baseURL: string = \"/organizations\";\n\n  async get(): Promise<Organization> {\n    const respnose = await this._execute<OrganizationSchema>(\"/current\");\n\n    return {\n      id: respnose.orgID,\n      name: respnose.name,\n    };\n  }\n}\n","import type { Region, RegionSchema } from \"./region\";\n\nimport { APIManager } from \"../api/manager\";\n\nexport class RegionManager extends APIManager {\n  protected _baseURL: string = \"/regions\";\n\n  async get<\n    T extends { id: RegionSchema[\"regionID\"] } | { name: RegionSchema[\"region\"] } | undefined = undefined,\n    _ReturnType = T extends { id: RegionSchema[\"regionID\"] } | { name: RegionSchema[\"region\"] } ? Region | undefined : Region[],\n  >(where?: T): Promise<_ReturnType> {\n    const response = await this._execute<RegionSchema[]>();\n\n    if (where && (\"id\" in where || \"name\" in where)) {\n      const region = response.find((region) => {\n        if (\"id\" in where) return region.regionID === where.id;\n        if (\"name\" in where) return region.region === where.name;\n        return false;\n      });\n\n      if (!region) return undefined as _ReturnType;\n\n      return {\n        id: region.regionID,\n        name: region.region,\n        provider: region.provider,\n      } as _ReturnType;\n    }\n\n    return response.map((data) => ({\n      id: data.regionID,\n      name: data.region,\n      provider: data.provider,\n    })) as _ReturnType;\n  }\n}\n","import type { Defined } from \"@repo/utils\";\n\nimport { type API, APIManager } from \"../api\";\n\nexport interface SecretSchema {\n  secretID: string;\n  name: string;\n  value: string | undefined;\n  lastUpdatedBy: string;\n  lastUpdatedAt: string;\n  createdBy: string;\n  createdAt: string;\n}\n\nexport class Secret extends APIManager {\n  protected _baseURL: string;\n\n  constructor(\n    api: API,\n    public id: SecretSchema[\"secretID\"],\n    public name: SecretSchema[\"name\"],\n    public value: SecretSchema[\"value\"],\n    public lastUpdatedBy: SecretSchema[\"lastUpdatedBy\"],\n    public lastUpdatedAt: Date,\n    public createdBy: SecretSchema[\"createdBy\"],\n    public createdAt: Date,\n  ) {\n    super(api);\n    this._baseURL = Secret.getBaseURL(this.id);\n  }\n\n  static getBaseURL(id: SecretSchema[\"secretID\"]) {\n    return `/secrets/${id}`;\n  }\n\n  static async update(api: API, id: SecretSchema[\"secretID\"], value: Defined<SecretSchema[\"value\"]>): Promise<Secret> {\n    const response = await api.execute<SecretSchema>(this.getBaseURL(id), {\n      method: \"PATCH\",\n      body: JSON.stringify({ value }),\n    });\n\n    return new Secret(\n      api,\n      response.secretID,\n      response.name,\n      response.value,\n      response.lastUpdatedBy,\n      new Date(response.lastUpdatedAt),\n      response.createdBy,\n      new Date(response.createdAt),\n    );\n  }\n\n  static async delete(api: API, id: SecretSchema[\"secretID\"]): Promise<SecretSchema[\"secretID\"]> {\n    const response = await api.execute<Pick<SecretSchema, \"secretID\">>(this.getBaseURL(id), { method: \"DELETE\" });\n    return response.secretID;\n  }\n\n  async update(value: Defined<SecretSchema[\"value\"]>) {\n    return Secret.update(this._api, this.id, value);\n  }\n\n  async delete() {\n    return Secret.delete(this._api, this.id);\n  }\n}\n","import type { Defined, Tail } from \"@repo/utils\";\n\nimport { APIManager } from \"../api/manager\";\n\nimport { Secret, type SecretSchema } from \"./secret\";\n\nexport interface CreateSecretBody {\n  name: SecretSchema[\"name\"];\n  value: Defined<SecretSchema[\"value\"]>;\n}\n\nexport class SecretManager extends APIManager {\n  protected _baseURL: string = \"/secrets\";\n\n  private _create(data: SecretSchema): Secret {\n    return new Secret(\n      this._api,\n      data.secretID,\n      data.name,\n      data.value,\n      data.lastUpdatedBy,\n      new Date(data.lastUpdatedAt),\n      data.createdBy,\n      new Date(data.createdAt),\n    );\n  }\n\n  async create(body: CreateSecretBody) {\n    const response = await this._execute<{ secret: SecretSchema }>(\"\", {\n      method: \"POST\",\n      body: JSON.stringify(body),\n    });\n    return this._create(response.secret);\n  }\n\n  async get<\n    T extends { id: SecretSchema[\"secretID\"] } | { name: SecretSchema[\"name\"] } | undefined = undefined,\n    _TReturnType = T extends undefined ? Secret[] : Secret | undefined,\n  >(where?: T): Promise<_TReturnType> {\n    let url = \"\";\n    const params = new URLSearchParams();\n\n    if (where) {\n      if (\"name\" in where) {\n        params.set(\"name\", where.name);\n      } else if (\"id\" in where) {\n        url = `${url}/${where.id}`;\n      }\n    }\n\n    type Response = T extends undefined\n      ? SecretSchema[]\n      : T extends { id: string }\n        ? { secret: SecretSchema }\n        : { secrets: SecretSchema[] };\n    const response = await this._execute<Response>(`${url}?${params.toString()}`);\n\n    if (\"secrets\" in response) {\n      if (!where) {\n        return response.secrets.map((data) => this._create(data)) as _TReturnType;\n      }\n\n      if (response.secrets[0]) {\n        return this._create(response.secrets[0]) as _TReturnType;\n      }\n    }\n\n    if (\"secret\" in response && response.secret) {\n      return this._create(response.secret) as _TReturnType;\n    }\n\n    return [] as unknown as _TReturnType;\n  }\n\n  async update(...args: Tail<Parameters<typeof Secret.update>>) {\n    return Secret.update(this._api, ...args);\n  }\n\n  async delete(...args: Tail<Parameters<typeof Secret.delete>>) {\n    return Secret.delete(this._api, ...args);\n  }\n}\n","import { type API, APIManager } from \"../api\";\n\nexport interface TeamMemberTeamSchema {\n  teamID: string;\n  name: string;\n  description: string;\n}\n\nexport interface TeamMemberTeam extends Omit<TeamMemberTeamSchema, \"teamID\"> {\n  id: string;\n}\n\nexport interface TeamMemberUserSchema {\n  userID: string;\n  firstName: string;\n  lastName: string;\n  email: string;\n}\n\nexport interface TeamMemberUser extends Omit<TeamMemberUserSchema, \"userID\"> {\n  id: string;\n}\n\nexport interface TeamSchema {\n  teamID: string;\n  name: string;\n  description: string;\n  memberTeams: TeamMemberTeamSchema[] | undefined;\n  memberUsers: TeamMemberUserSchema[] | undefined;\n  createdAt: string;\n}\n\nexport interface UpdateTeamBody extends Partial<Pick<TeamSchema, \"name\" | \"description\">> {}\n\nexport class Team extends APIManager {\n  protected _baseURL: string;\n\n  constructor(\n    api: API,\n    public id: TeamSchema[\"teamID\"],\n    public name: TeamSchema[\"name\"],\n    public description: TeamSchema[\"description\"],\n    public memberTeams: TeamMemberTeam[] | undefined,\n    public memberUsers: TeamMemberUser[] | undefined,\n    public createdAt: Date,\n  ) {\n    super(api);\n    this._baseURL = Team.getBaseURL(this.id);\n  }\n\n  static getBaseURL(id: TeamSchema[\"teamID\"]) {\n    return `/teams/${id}`;\n  }\n\n  static async update(api: API, id: TeamSchema[\"teamID\"], body: UpdateTeamBody): Promise<TeamSchema[\"teamID\"]> {\n    const response = await api.execute<Pick<TeamSchema, \"teamID\">>(this.getBaseURL(id), {\n      method: \"PATCH\",\n      body: JSON.stringify(body),\n    });\n\n    return response.teamID;\n  }\n\n  static async delete(api: API, id: TeamSchema[\"teamID\"]): Promise<TeamSchema[\"teamID\"]> {\n    const response = await api.execute<Pick<TeamSchema, \"teamID\">>(this.getBaseURL(id), { method: \"DELETE\" });\n    return response.teamID;\n  }\n\n  static async addMemberTeams(\n    api: API,\n    id: TeamSchema[\"teamID\"],\n    teamIDs: TeamMemberTeamSchema[\"teamID\"][],\n  ): Promise<TeamSchema[\"teamID\"]> {\n    const response = await api.execute<Pick<TeamSchema, \"teamID\">>(this.getBaseURL(id), {\n      method: \"PATCH\",\n      body: JSON.stringify({ addMemberTeamIDs: teamIDs }),\n    });\n\n    return response.teamID;\n  }\n\n  static async removeMemberTeams(\n    api: API,\n    id: TeamSchema[\"teamID\"],\n    teamIDs: TeamMemberTeamSchema[\"teamID\"][],\n  ): Promise<TeamSchema[\"teamID\"]> {\n    const response = await api.execute<Pick<TeamSchema, \"teamID\">>(this.getBaseURL(id), {\n      method: \"PATCH\",\n      body: JSON.stringify({ removeMemberTeamIDs: teamIDs }),\n    });\n\n    return response.teamID;\n  }\n\n  static async addMemberUsers(\n    api: API,\n    id: TeamSchema[\"teamID\"],\n    userIDs: TeamMemberUserSchema[\"userID\"][],\n  ): Promise<TeamSchema[\"teamID\"]> {\n    const response = await api.execute<Pick<TeamSchema, \"teamID\">>(this.getBaseURL(id), {\n      method: \"PATCH\",\n      body: JSON.stringify({ addMemberUserIDs: userIDs }),\n    });\n\n    return response.teamID;\n  }\n\n  static async removeMemberUsers(\n    api: API,\n    id: TeamSchema[\"teamID\"],\n    userIDs: TeamMemberUserSchema[\"userID\"][],\n  ): Promise<TeamSchema[\"teamID\"]> {\n    const response = await api.execute<Pick<TeamSchema, \"teamID\">>(this.getBaseURL(id), {\n      method: \"PATCH\",\n      body: JSON.stringify({ removeMemberUserIDs: userIDs }),\n    });\n\n    return response.teamID;\n  }\n\n  async update(body: UpdateTeamBody) {\n    return Team.update(this._api, this.id, body);\n  }\n\n  async delete() {\n    return Team.delete(this._api, this.id);\n  }\n\n  async addMemberTeams(teamIDs: TeamMemberTeamSchema[\"teamID\"][]) {\n    return Team.addMemberTeams(this._api, this.id, teamIDs);\n  }\n\n  async removeMemberTeams(teamIDs: TeamMemberTeamSchema[\"teamID\"][]) {\n    return Team.removeMemberTeams(this._api, this.id, teamIDs);\n  }\n\n  async addMemberUsers(userIDs: TeamMemberUserSchema[\"userID\"][]) {\n    return Team.addMemberUsers(this._api, this.id, userIDs);\n  }\n\n  async removeMemberUsers(userIDs: TeamMemberUserSchema[\"userID\"][]) {\n    return Team.removeMemberUsers(this._api, this.id, userIDs);\n  }\n}\n","import type { Tail } from \"@repo/utils\";\n\nimport { APIManager } from \"../api/manager\";\n\nimport { Team, type TeamMemberTeamSchema, type TeamMemberUserSchema, type TeamSchema } from \"./team\";\n\nexport interface CreateTeamBody {\n  name: TeamSchema[\"name\"];\n  description?: TeamSchema[\"description\"];\n  memberTeams?: TeamMemberTeamSchema[\"teamID\"][];\n  memberUsers?: TeamMemberUserSchema[\"userID\"][];\n}\n\nexport class TeamManager extends APIManager {\n  protected _baseURL: string = \"/teams\";\n\n  private _create(data: TeamSchema): Team {\n    return new Team(\n      this._api,\n      data.teamID,\n      data.name,\n      data.description,\n      data.memberTeams?.map(({ teamID, ...team }) => ({ ...team, id: teamID })),\n      data.memberUsers?.map(({ userID, ...user }) => ({ ...user, id: userID })),\n      new Date(data.createdAt),\n    );\n  }\n\n  async create({ memberTeams, memberUsers, ...body }: CreateTeamBody) {\n    let newTeam = await this._execute<TeamSchema>(\"\", {\n      method: \"POST\",\n      body: JSON.stringify(body),\n    });\n\n    if (memberTeams?.length || memberUsers?.length) {\n      await this._execute(`/${newTeam.teamID}`, {\n        method: \"PATCH\",\n        body: JSON.stringify({\n          addMemberTeamIDs: memberTeams,\n          addMemberUserIDs: memberUsers,\n        }),\n      });\n\n      newTeam = await this._execute(`/${newTeam.teamID}`);\n    }\n\n    return this._create(newTeam);\n  }\n\n  async get<\n    T extends\n      | { id: TeamSchema[\"teamID\"] }\n      | { name: TeamSchema[\"name\"] }\n      | { description: TeamSchema[\"description\"] }\n      | undefined = undefined,\n    _TReturnType = T extends undefined ? Team[] : Team | undefined,\n  >(where?: T) {\n    let url = \"\";\n    const params = new URLSearchParams();\n\n    if (where) {\n      if (\"id\" in where) {\n        url = `${url}/${where.id}`;\n      } else {\n        params.set(...Object.entries(where)[0]!);\n      }\n    }\n\n    const response = await this._execute<T extends undefined ? TeamSchema[] : TeamSchema>(`${url}?${params.toString()}`);\n\n    if (Array.isArray(response)) {\n      return response.map((data) => this._create(data)) as _TReturnType;\n    }\n\n    return this._create(response) as _TReturnType;\n  }\n\n  async update(...args: Parameters<typeof Team.update> extends [any, ...infer Rest] ? Rest : never) {\n    return Team.update(this._api, ...args);\n  }\n\n  async delete(...args: Tail<Parameters<typeof Team.delete>>) {\n    return Team.delete(this._api, ...args);\n  }\n\n  async addMemberTeams(...args: Tail<Parameters<typeof Team.addMemberTeams>>) {\n    return Team.addMemberTeams(this._api, ...args);\n  }\n\n  async removeMemberTeams(...args: Tail<Parameters<typeof Team.removeMemberTeams>>) {\n    return Team.removeMemberTeams(this._api, ...args);\n  }\n\n  async addMemberUsers(...args: Tail<Parameters<typeof Team.addMemberUsers>>) {\n    return Team.addMemberUsers(this._api, ...args);\n  }\n\n  async removeMemberUsers(...args: Tail<Parameters<typeof Team.removeMemberUsers>>) {\n    return Team.removeMemberUsers(this._api, ...args);\n  }\n}\n","import { createPool, type Pool, type PoolOptions } from \"mysql2/promise\";\n\nexport interface ConnectionConfig extends Partial<Omit<PoolOptions, \"name\">> {}\n\nexport type ConnectionClient = Pool;\n\nexport class Connection {\n  client: ConnectionClient;\n\n  constructor(public config: ConnectionConfig) {\n    this.client = createPool({ multipleStatements: true, ...this.config });\n  }\n\n  async disconnect(): Promise<void> {\n    await this.client.end();\n  }\n}\n","import type { ConnectionClient } from \"../connection\";\nimport type { DatabaseName } from \"../database\";\nimport type { TableName } from \"../table\";\nimport type { Optional } from \"@repo/utils\";\nimport type { FieldPacket, ResultSetHeader } from \"mysql2/promise\";\n\nexport type ColumnName = string;\n\nexport type ColumnType = any;\n\nexport interface ColumnSchema {\n  name: ColumnName;\n  type: string;\n  nullable: boolean;\n  primaryKey: boolean;\n  autoIncrement: boolean;\n  default: any;\n  clauses: string[];\n}\n\nexport interface AddColumnSchema\n  extends Optional<ColumnSchema, \"nullable\" | \"primaryKey\" | \"autoIncrement\" | \"default\" | \"clauses\"> {}\n\nexport interface ColumnInfo<TName extends ColumnName> {\n  name: TName;\n  type: string;\n  null: string;\n  key: string;\n  default: any;\n  extra: string;\n}\n\nexport class Column<TName extends ColumnName, TTableName extends TableName, TDatabaseName extends DatabaseName> {\n  constructor(\n    private _client: ConnectionClient,\n    private _path: string,\n    public name: TName,\n    public tableName: TTableName,\n    public databaseName: TDatabaseName,\n  ) {}\n\n  static schemaToClauses(schema: Partial<ColumnSchema>): string {\n    const clauses: string[] = [`\\`${schema.name}\\``];\n    if (schema.type) clauses.push(schema.type);\n    if (schema.nullable !== undefined && !schema.nullable) clauses.push(\"NOT NULL\");\n    if (schema.primaryKey) clauses.push(\"PRIMARY KEY\");\n    if (schema.autoIncrement) clauses.push(\"AUTO_INCREMENT\");\n    if (schema.default !== undefined) clauses.push(`DEFAULT ${schema.default}`);\n    return [...clauses, ...(schema.clauses || [])].filter(Boolean).join(\" \");\n  }\n\n  static async drop<TName extends ColumnName, TTableName extends TableName, TDatabaseName extends DatabaseName>(\n    client: ConnectionClient,\n    databaseName: TDatabaseName,\n    tableName: TTableName,\n    name: TName,\n  ): Promise<[ResultSetHeader, FieldPacket[]]> {\n    return client.execute<ResultSetHeader>(`\\\n      ALTER TABLE ${databaseName}.${tableName} DROP COLUMN ${name}\n    `);\n  }\n\n  static normalizeInfo<TName extends ColumnName>(info: any): ColumnInfo<TName> {\n    return {\n      name: info.Field,\n      type: info.Type,\n      null: info.Null,\n      key: info.Key,\n      default: info.Default,\n      extra: info.Extra,\n    };\n  }\n\n  static async modify<TName extends ColumnName>(\n    client: ConnectionClient,\n    path: string,\n    name: TName,\n    schema: Partial<Omit<ColumnSchema, \"name\">>,\n  ): Promise<[ResultSetHeader, FieldPacket[]]> {\n    const clauses = Column.schemaToClauses({ type: \"\", ...schema, name });\n\n    return client.execute<ResultSetHeader>(`\\\n      ALTER TABLE ${path} MODIFY COLUMN ${clauses}\n    `);\n  }\n\n  static async rename<TName extends ColumnName>(\n    client: ConnectionClient,\n    path: string,\n    name: TName,\n    newName: ColumnName,\n  ): Promise<[ResultSetHeader, FieldPacket[]]> {\n    const result = await client.execute<ResultSetHeader>(`\\\n      ALTER TABLE ${path} CHANGE ${name} ${newName}\n    `);\n\n    return result;\n  }\n\n  static async showInfo<TName extends ColumnName, TTableName extends TableName, TDatabaseName extends DatabaseName>(\n    client: ConnectionClient,\n    databaseName: TDatabaseName,\n    tableName: TTableName,\n    name: TName,\n  ): Promise<ColumnInfo<TName>> {\n    const [rows] = await client.query<any[]>(`SHOW COLUMNS IN ${tableName} IN ${databaseName} LIKE '${name}'`);\n    return Column.normalizeInfo<TName>(rows[0]);\n  }\n\n  async drop() {\n    return Column.drop(this._client, this.databaseName, this.tableName, this.name);\n  }\n\n  async modify(...args: Parameters<typeof Column.modify> extends [any, any, any, ...infer Rest] ? Rest : never) {\n    return Column.modify(this._client, this._path, this.name, ...args);\n  }\n\n  async rename(...[newName, ...args]: Parameters<typeof Column.rename> extends [any, any, any, ...infer Rest] ? Rest : never) {\n    const result = await Column.rename(this._client, this._path, this.name, newName, ...args);\n    this.name = newName as TName;\n    return result;\n  }\n\n  async showInfo() {\n    return Column.showInfo<TName, TTableName, TDatabaseName>(this._client, this.databaseName, this.tableName, this.name);\n  }\n}\n","import { ResultSetHeader } from \"mysql2/promise\";\n\nimport type { ConnectionClient } from \"../connection\";\nimport type { DatabaseName } from \"../database\";\nimport type { TableName, TableType, TableColumnName } from \"../table\";\n\nimport { type ColumnName, Column, type AddColumnSchema } from \"./column\";\n\nexport class ColumnManager<TTableName extends TableName, TTableType extends TableType, TDatabaseName extends DatabaseName> {\n  private _path: string;\n\n  constructor(\n    private _client: ConnectionClient,\n    public tableName: TTableName,\n    public databaseName: TDatabaseName,\n  ) {\n    this._path = [databaseName, tableName].join(\".\");\n  }\n\n  use<TName extends TableColumnName<TTableType> | (ColumnName & {})>(name: TName) {\n    return new Column<TName, TTableName, TDatabaseName>(this._client, this._path, name, this.tableName, this.databaseName);\n  }\n\n  async add<TSchema extends AddColumnSchema>(schema: TSchema) {\n    const clauses = Column.schemaToClauses(schema);\n\n    await this._client.execute<ResultSetHeader>(`\\\n      ALTER TABLE ${this.databaseName}.${this.tableName} ADD COLUMN ${clauses}\n    `);\n\n    return new Column<TSchema[\"name\"], TTableName, TDatabaseName>(\n      this._client,\n      this._path,\n      schema.name,\n      this.tableName,\n      this.databaseName,\n    );\n  }\n\n  async drop(name: TableColumnName<TTableType> | (ColumnName & {})) {\n    return Column.drop(this._client, this.databaseName, this.tableName, name);\n  }\n\n  async modify(\n    name: TableColumnName<TTableType> | (ColumnName & {}),\n    ...args: Parameters<typeof Column.modify> extends [any, any, any, ...infer Rest] ? Rest : never\n  ) {\n    return Column.modify(this._client, this._path, name, ...args);\n  }\n\n  async rename(\n    name: TableColumnName<TTableType> | (ColumnName & {}),\n    ...args: Parameters<typeof Column.rename> extends [any, any, any, ...infer Rest] ? Rest : never\n  ) {\n    return Column.rename(this._client, this._path, name, ...args);\n  }\n\n  async showInfo<TName extends TableColumnName<TTableType> | (ColumnName & {})>(\n    name: TName,\n    ...args: Parameters<typeof Column.showInfo> extends [any, any, any, any, ...infer Rest] ? Rest : never\n  ) {\n    return Column.showInfo<TName, TTableName, TDatabaseName>(this._client, this.databaseName, this.tableName, name, ...args);\n  }\n}\n","import { escape } from \"mysql2\";\n\nimport type { DatabaseType } from \"../database\";\nimport type { TableType } from \"../table\";\n\ntype MergeUnion<T> = (T extends any ? (i: T) => void : never) extends (i: infer U) => void ? { [K in keyof U]: U[K] } : never;\n\ntype JoinType = \"INNER\" | \"LEFT\" | \"RIGHT\" | \"FULL\";\ntype JoinOperator = \"=\" | \"<\" | \">\" | \"<=\" | \">=\" | \"!=\";\n\nexport type JoinClause<TTableType extends TableType, TDatabaseType extends DatabaseType, TAs extends string> = {\n  [K in keyof TDatabaseType[\"tables\"]]: {\n    type?: JoinType;\n    table: K;\n    as: TAs;\n    on: [(string & {}) | keyof TTableType, JoinOperator, (string & {}) | keyof TDatabaseType[\"tables\"][K][\"columns\"]];\n  };\n}[keyof TDatabaseType[\"tables\"]];\n\nexport type ExtractJoinClauseColumns<\n  TTableType extends TableType,\n  TDatabaseType extends DatabaseType,\n  TJoinClauseAs extends string,\n  TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[],\n> = {\n  [K in TJoinClauses[number] as K[\"as\"]]: `${K[\"as\"]}.${Extract<keyof TDatabaseType[\"tables\"][K[\"table\"]][\"columns\"], string>}`;\n}[TJoinClauses[number][\"as\"]];\n\nexport type SelectClause<\n  TTableType extends TableType,\n  TDatabaseType extends DatabaseType,\n  TJoinClauseAs extends string,\n  TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[],\n> = (\n  | \"*\"\n  | keyof TTableType\n  | ExtractJoinClauseColumns<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>\n  | `${TJoinClauseAs}.*`\n  | `${string} AS ${string}`\n)[];\n\nexport type WhereOperator<TColumnValue> = TColumnValue extends string\n  ? {\n      eq?: TColumnValue;\n      ne?: TColumnValue;\n      like?: string;\n      in?: TColumnValue[];\n      nin?: TColumnValue[];\n    }\n  : TColumnValue extends number | Date\n    ? {\n        eq?: TColumnValue;\n        ne?: TColumnValue;\n        gt?: TColumnValue;\n        gte?: TColumnValue;\n        lt?: TColumnValue;\n        lte?: TColumnValue;\n        in?: TColumnValue[];\n        nin?: TColumnValue[];\n      }\n    : never;\n\nexport type WhereClause<\n  TTableType extends TableType,\n  TDatabaseType extends DatabaseType,\n  TJoinClauseAs extends string,\n  TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[],\n> = ({\n  [K in keyof TTableType]?: WhereOperator<TTableType[K]> | TTableType[K];\n} & {\n  [K in TJoinClauses[number] as K[\"as\"]]: {\n    [C in keyof TDatabaseType[\"tables\"][K[\"table\"]][\"columns\"] as `${K[\"as\"]}.${Extract<C, string>}`]?:\n      | WhereOperator<TDatabaseType[\"tables\"][K[\"table\"]][\"columns\"][C]>\n      | TDatabaseType[\"tables\"][K[\"table\"]][\"columns\"][C];\n  };\n}[TJoinClauses[number][\"as\"]]) & {\n  OR?: WhereClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>[];\n  NOT?: WhereClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>;\n};\n\nexport type GroupByClause<\n  TTableType extends TableType,\n  TDatabaseType extends DatabaseType,\n  TJoinClauseAs extends string,\n  TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[],\n> = ((string & {}) | keyof TTableType | ExtractJoinClauseColumns<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>)[];\n\nexport type OrderByDirection = \"asc\" | \"desc\";\n\nexport type OrderByClause<\n  TTableType extends TableType,\n  TDatabaseType extends DatabaseType,\n  TJoinClauseAs extends string,\n  TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[],\n> = {\n  [K in\n    | (string & {})\n    | keyof TTableType\n    | Extract<ExtractJoinClauseColumns<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>, string>]?: OrderByDirection;\n};\n\nexport interface QueryBuilderParams<\n  TTableType extends TableType,\n  TDatabaseType extends DatabaseType,\n  TJoinClauseAs extends string,\n  TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[],\n  TSelectClause extends SelectClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>,\n> {\n  join?: TJoinClauses;\n  select?: TSelectClause;\n  where?: WhereClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>;\n  groupBy?: GroupByClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>;\n  orderBy?: OrderByClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>;\n  limit?: number;\n  offset?: number;\n}\n\nexport type AnyQueryBuilderParams = QueryBuilderParams<any, any, any, any, any>;\n\nexport type ExtractSelectedQueryColumns<\n  TTableType extends TableType,\n  TDatabaseType extends DatabaseType,\n  TJoinClauseAs extends string,\n  TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[],\n  TSelectClause extends SelectClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>,\n> = TSelectClause extends (infer TColumn)[]\n  ? MergeUnion<\n      TColumn extends \"*\"\n        ? TTableType\n        : TColumn extends keyof TTableType\n          ? { [K in TColumn]: TTableType[K] }\n          : TColumn extends `${infer TJoinAs}.${infer TJoinColumn}`\n            ? TJoinAs extends TJoinClauseAs\n              ? TJoinColumn extends keyof TDatabaseType[\"tables\"][Extract<\n                  TJoinClauses[number],\n                  { as: TJoinAs }\n                >[\"table\"]][\"columns\"]\n                ? {\n                    [K in `${TJoinAs}_${TJoinColumn}`]: TDatabaseType[\"tables\"][Extract<\n                      TJoinClauses[number],\n                      { as: TJoinAs }\n                    >[\"table\"]][\"columns\"][TJoinColumn];\n                  }\n                : never\n              : never\n            : TColumn extends `${infer TAlias}.*`\n              ? TAlias extends TJoinClauseAs\n                ? TDatabaseType[\"tables\"][Extract<TJoinClauses[number], { as: TAlias }>[\"table\"]][\"columns\"]\n                : never\n              : TColumn extends `${string} AS ${infer TAs}`\n                ? { [K in TAs]: any }\n                : never\n    >\n  : never;\n\nconst ALIAS_PATTERN = /(.+)\\s+AS\\s+(.+)/i;\n\nfunction extractSelectClauseAliases(selectClauses: string[] = []): string[] {\n  return selectClauses\n    .map((column) => {\n      const match = column.match(ALIAS_PATTERN);\n      return match ? match[2]?.trim() : null;\n    })\n    .filter((alias): alias is string => alias !== null);\n}\n\nfunction isJoinColumn<TTableType extends TableType, TDatabaseType extends DatabaseType, TJoinClauseAs extends string>(\n  column: string,\n  joinClauses: JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[] = [],\n) {\n  for (const clause of joinClauses) {\n    if (column.startsWith(`${clause.as}.`)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport class QueryBuilder<TTableType extends TableType, TDatabaseType extends DatabaseType> {\n  constructor(\n    private _databaseName: string,\n    private _tableName: string,\n  ) {}\n\n  buildJoinClause<TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[]>(\n    clauses?: TJoinClauses,\n  ) {\n    if (!clauses || clauses.length === 0) return \"\";\n    return clauses\n      .map((clause) => {\n        let left = String(clause.on[0]);\n        left = isJoinColumn(left, clauses) ? left : `${this._tableName}.${left}`;\n        let right = String(clause.on[2]);\n        right = isJoinColumn(right, clauses) ? right : `${clause.as}.${right}`;\n        const joinType = clause.type ? `${clause.type} JOIN` : \"JOIN\";\n        const tableName = `${this._databaseName}.${String(clause.table)} AS ${clause.as}`;\n        const onCondition = `${left} ${clause.on[1]} ${right}`;\n        return `${joinType} ${tableName} ON ${onCondition}`;\n      })\n      .join(\" \");\n  }\n\n  buildSelectClause<TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[]>(\n    clauses?: SelectClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>,\n    joinClauses?: TJoinClauses,\n  ) {\n    let _clauses = clauses?.length ? clauses : [];\n\n    if (!clauses?.length) {\n      _clauses.push(\"*\");\n    }\n\n    if (joinClauses?.length) {\n      if (!clauses?.length) {\n        _clauses = [..._clauses, ...joinClauses.map((join) => `${join.as}.*`)];\n      }\n\n      _clauses = _clauses.map((column) => {\n        const _column = String(column);\n\n        if (isJoinColumn(_column, joinClauses)) {\n          const [tableName, columnName] = _column.split(\".\");\n          return `${_column}${!_column.endsWith(\"*\") ? ` AS ${tableName}_${columnName}` : \"\"}`;\n        }\n\n        if (ALIAS_PATTERN.test(_column)) {\n          return _column;\n        }\n\n        return `${this._tableName}.${_column}${!_column.endsWith(\"*\") ? ` AS ${_column}` : \"\"}`;\n      });\n    }\n\n    return `SELECT ${_clauses.join(\", \")}`;\n  }\n\n  buildFromClause(hasJoinClauses?: boolean) {\n    return `FROM ${this._databaseName}.${this._tableName}${hasJoinClauses ? ` AS ${this._tableName}` : \"\"}`;\n  }\n\n  buildWhereCondition(column: string, operator: string, value: any): string {\n    switch (operator) {\n      case \"eq\":\n        return `${column} = ${escape(value)}`;\n      case \"ne\":\n        return `${column} != ${escape(value)}`;\n      case \"gt\":\n        return `${column} > ${escape(value)}`;\n      case \"gte\":\n        return `${column} >= ${escape(value)}`;\n      case \"lt\":\n        return `${column} < ${escape(value)}`;\n      case \"lte\":\n        return `${column} <= ${escape(value)}`;\n      case \"in\":\n        return `${column} IN (${value.map(escape).join(\", \")})`;\n      case \"nin\":\n        return `${column} NOT IN (${value.map(escape).join(\", \")})`;\n      case \"like\":\n        return `${column} LIKE ${escape(value)}`;\n      default:\n        throw new Error(`Unsupported operator: ${operator}`);\n    }\n  }\n\n  buildWhereClause<TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[]>(\n    clauses?: WhereClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>,\n    joinClauses?: TJoinClauses,\n  ): string {\n    if (!clauses || !Object.keys(clauses).length) return \"\";\n\n    const _clauses: string[] = [];\n\n    for (const [column, value] of Object.entries(clauses) as [string, any][]) {\n      if (value === undefined) continue;\n      if (column === \"OR\" && Array.isArray(value)) {\n        _clauses.push(`(${value.map((v) => `(${this.buildWhereClause(v, joinClauses)})`).join(\" OR \")})`);\n      } else if (column === \"NOT\" && typeof value === \"object\") {\n        _clauses.push(`NOT (${this.buildWhereClause(value, joinClauses)})`);\n      } else if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n        for (const [operator, _value] of Object.entries(value) as [string, any][]) {\n          if (_value === undefined) continue;\n\n          const _column = joinClauses?.length\n            ? isJoinColumn(column, joinClauses)\n              ? column\n              : `${this._tableName}.${column}`\n            : column;\n\n          _clauses.push(this.buildWhereCondition(_column, operator, _value));\n        }\n      } else {\n        const _column = joinClauses?.length\n          ? isJoinColumn(column, joinClauses)\n            ? column\n            : `${this._tableName}.${column}`\n          : column;\n\n        _clauses.push(this.buildWhereCondition(_column, \"eq\", value));\n      }\n    }\n\n    if (!_clauses.length) return \"\";\n\n    return `WHERE ${_clauses.join(\" AND \")}`;\n  }\n\n  buildGroupByClause<TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[]>(\n    clauses?: GroupByClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>,\n    joinClauses?: TJoinClauses,\n    aliases?: string[],\n  ): string {\n    if (!clauses || !clauses.length) return \"\";\n\n    const _clauses = clauses.map((column) => {\n      const _column = String(column);\n\n      if (aliases?.includes(_column)) {\n        return _column;\n      }\n\n      return joinClauses?.length ? (isJoinColumn(_column, joinClauses) ? _column : `${this._tableName}.${_column}`) : _column;\n    });\n\n    return `GROUP BY ${_clauses.join(\", \")}`;\n  }\n\n  buildOrderByClause<TJoinClauseAs extends string, TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[]>(\n    clauses?: OrderByClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>,\n    joinClauses?: TJoinClauses,\n    aliases?: string[],\n  ): string {\n    if (!clauses) return \"\";\n\n    const condition = Object.entries(clauses)\n      .map(([column, direction = \"asc\"]) => {\n        let _column = String(column);\n\n        if (aliases?.includes(_column)) {\n          return _column;\n        }\n\n        _column = joinClauses?.length\n          ? isJoinColumn(_column, joinClauses)\n            ? _column\n            : `${this._tableName}.${_column}`\n          : _column;\n\n        return `${_column} ${direction.toUpperCase()}`;\n      })\n      .join(\", \");\n\n    return condition ? `ORDER BY ${condition}` : \"\";\n  }\n\n  buildLimitClause(limit?: number): string {\n    return typeof limit === \"number\" ? `LIMIT ${limit}` : \"\";\n  }\n\n  buildOffsetClause(offset?: number): string {\n    return typeof offset === \"number\" ? `OFFSET ${offset}` : \"\";\n  }\n\n  buildClauses<\n    TJoinClauseAs extends string,\n    TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[],\n    TSelectClause extends SelectClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>,\n  >(params?: QueryBuilderParams<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses, TSelectClause>) {\n    const aliases = extractSelectClauseAliases(params?.select as string[]);\n\n    return {\n      select: this.buildSelectClause(params?.select, params?.join),\n      from: this.buildFromClause(Boolean(params?.join?.length)),\n      join: this.buildJoinClause(params?.join),\n      where: this.buildWhereClause(params?.where, params?.join),\n      groupBy: this.buildGroupByClause(params?.groupBy, params?.join, aliases),\n      orderBy: this.buildOrderByClause(params?.orderBy, params?.join, aliases),\n      limit: this.buildLimitClause(params?.limit),\n      offset: this.buildOffsetClause(params?.offset),\n    };\n  }\n\n  buildQuery<\n    TJoinClauseAs extends string,\n    TJoinClauses extends JoinClause<TTableType, TDatabaseType, TJoinClauseAs>[],\n    TSelectClause extends SelectClause<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses>,\n  >(params?: QueryBuilderParams<TTableType, TDatabaseType, TJoinClauseAs, TJoinClauses, TSelectClause>) {\n    return Object.values(this.buildClauses(params)).filter(Boolean).join(\" \").trim();\n  }\n}\n","import type { ConnectionClient } from \"../connection\";\nimport type { DatabaseType, DatabaseName } from \"../database\";\nimport type { Optional } from \"@repo/utils\";\nimport type { AnyAI, CreateChatCompletionResult } from \"@singlestore/ai\";\nimport type { FieldPacket, ResultSetHeader, RowDataPacket } from \"mysql2/promise\";\n\nimport { type ColumnType, type AddColumnSchema, ColumnManager, Column, type ColumnName } from \"../column\";\nimport {\n  type JoinClause,\n  type SelectClause,\n  type QueryBuilderParams,\n  type ExtractSelectedQueryColumns,\n  QueryBuilder,\n  type WhereClause,\n} from \"../query\";\n\nexport type TableName = string;\n\nexport interface TableType extends Record<ColumnName, ColumnType> {}\n\nexport interface TableSchema<TName extends TableName, TType extends TableType> {\n  name: TName;\n  columns: {\n    [K in keyof TType]: Omit<AddColumnSchema, \"name\">;\n  };\n  primaryKeys: string[];\n  fulltextKeys: string[];\n  clauses: string[];\n}\n\nexport interface CreateTableSchema<TName extends TableName, TType extends TableType>\n  extends Optional<TableSchema<TName, TType>, \"primaryKeys\" | \"fulltextKeys\" | \"clauses\"> {}\n\nexport interface TableInfo<TName extends TableName> {\n  name: TName;\n}\n\nexport interface TableInfoExtended<TName extends TableName> extends TableInfo<TName> {\n  tableType: string;\n  distributed: boolean;\n  storageType: string;\n}\n\nexport type TableColumnName<TType extends TableType> = Extract<keyof TType, string>;\n\nexport type VectorScoreKey = \"v_score\";\n\nexport class Table<\n  TName extends TableName,\n  TType extends TableType,\n  TDatabaseType extends DatabaseType,\n  TAI extends AnyAI | undefined,\n> {\n  private _path: string;\n  vScoreKey: VectorScoreKey = \"v_score\";\n  column: ColumnManager<TName, TType, TDatabaseType[\"name\"]>;\n\n  constructor(\n    private _client: ConnectionClient,\n    public name: TName,\n    public databaseName: TDatabaseType[\"name\"],\n    private _ai?: TAI,\n  ) {\n    this._path = [databaseName, name].join(\".\");\n    this.column = new ColumnManager(this._client, this.name, this.databaseName);\n  }\n\n  private get ai() {\n    if (!this._ai) {\n      throw new Error(\"AI instance is undefined. Ensure ai is properly initialized before accessing.\");\n    }\n\n    return this._ai;\n  }\n\n  static schemaToClauses(schema: CreateTableSchema<TableName, TableType>): string {\n    const clauses: string[] = [\n      ...Object.entries(schema.columns).map(([name, schema]) => {\n        return Column.schemaToClauses({ ...schema, name });\n      }),\n    ];\n\n    if (schema.primaryKeys?.length) clauses.push(`PRIMARY KEY (${schema.primaryKeys.join(\", \")})`);\n    if (schema.fulltextKeys?.length) clauses.push(`FULLTEXT KEY (${schema.fulltextKeys.join(\", \")})`);\n\n    return [...clauses, ...(schema.clauses || [])].filter(Boolean).join(\", \");\n  }\n\n  static normalizeInfo<\n    TName extends TableName,\n    TExtended extends boolean,\n    _ReturnType = TExtended extends true ? TableInfoExtended<TName> : TableInfo<TName>,\n  >(info: any, extended?: TExtended): _ReturnType {\n    const name = info[Object.keys(info).find((key) => key.startsWith(\"Tables_in_\")) as string];\n    if (!extended) return { name } as _ReturnType;\n\n    return {\n      name,\n      tableType: info.Table_type,\n      distributed: !!info.distributed,\n      storageType: info.Storage_type,\n    } as _ReturnType;\n  }\n\n  static async drop<TName extends TableName, TDatabaseName extends DatabaseName>(\n    client: ConnectionClient,\n    databaseName: TDatabaseName,\n    name: TName,\n  ): Promise<[ResultSetHeader, FieldPacket[]]> {\n    return client.execute<ResultSetHeader>(`\\\n      DROP TABLE IF EXISTS ${databaseName}.${name}\n    `);\n  }\n\n  static async truncate<TName extends TableName, TDatabaseName extends DatabaseName>(\n    client: ConnectionClient,\n    databaseName: TDatabaseName,\n    tableName: TName,\n  ): Promise<[ResultSetHeader, FieldPacket[]]> {\n    return client.execute<ResultSetHeader>(`\\\n      TRUNCATE TABLE ${databaseName}.${tableName}\n    `);\n  }\n\n  static async rename<TName extends TableName, TDatabaseName extends DatabaseName>(\n    client: ConnectionClient,\n    databaseName: TDatabaseName,\n    name: TName,\n    newName: TableName,\n  ): Promise<[ResultSetHeader, FieldPacket[]]> {\n    return client.execute<ResultSetHeader>(`\\\n      ALTER TABLE ${databaseName}.${name} RENAME TO ${newName}\n    `);\n  }\n\n  async drop() {\n    return Table.drop(this._client, this.databaseName, this.name);\n  }\n\n  async showInfo<TExtended extends boolean = false>(extended?: TExtended) {\n    const clauses = [`SHOW TABLES IN ${this.databaseName}`];\n    if (extended) clauses.push(\"EXTENDED\");\n    clauses.push(`LIKE '${this.name}'`);\n    const [rows] = await this._client.query<any[]>(clauses.join(\" \"));\n    return Table.normalizeInfo<TName, TExtended>(rows[0], extended);\n  }\n\n  async showColumnsInfo() {\n    const [rows] = await this._client.query<any[]>(`SHOW COLUMNS IN ${this.name} IN ${this.databaseName}`);\n    return rows.map((row) => Column.normalizeInfo<TableColumnName<TType>>(row));\n  }\n\n  async truncate() {\n    return Table.truncate(this._client, this.databaseName, this.name);\n  }\n\n  async rename(...[newName, ...args]: Parameters<typeof Table.rename> extends [any, any, any, ...infer Rest] ? Rest : never) {\n    const result = await Table.rename(this._client, this.databaseName, this.name, newName, ...args);\n    this.name = newName as TName;\n    return result;\n  }\n\n  async insert(values: Partial<TType> | Partial<TType>[]) {\n    const _values = Array.isArray(values) ? values : [values];\n    const keys = Object.keys(_values[0]!);\n    const placeholders = `(${keys.map(() => \"?\").join(\", \")})`;\n\n    return Promise.all(\n      _values.map((data) => {\n        const query = `INSERT INTO ${this._path} (${keys}) VALUES ${placeholders}`;\n        return this._client.execute<ResultSetHeader>(query, Object.values(data));\n      }),\n    );\n  }\n\n  async find<\n    TJoinClauseAs extends string,\n    TJoinClauses extends JoinClause<TType, TDatabaseType, TJoinClauseAs>[],\n    TSelectClause extends SelectClause<TType, TDatabaseType, TJoinClauseAs, TJoinClauses>,\n  >(params?: QueryBuilderParams<TType, TDatabaseType, TJoinClauseAs, TJoinClauses, TSelectClause>) {\n    type SelectedColumn = ExtractSelectedQueryColumns<TType, TDatabaseType, TJoinClauseAs, TJoinClauses, TSelectClause>;\n    const queryBuilder = new QueryBuilder<TType, TDatabaseType>(this.databaseName, this.name);\n    const query = queryBuilder.buildQuery(params);\n    const [rows] = await this._client.execute<(SelectedColumn & RowDataPacket)[]>(query);\n    return rows as SelectedColumn[];\n  }\n\n  async update(values: Partial<TType>, where: WhereClause<TType, TDatabaseType, any, any>) {\n    const _where = new QueryBuilder(this.databaseName, this.name).buildWhereClause(where);\n\n    const columnAssignments = Object.keys(values)\n      .map((key) => `${key} = ?`)\n      .join(\", \");\n\n    const query = `UPDATE ${this._path} SET ${columnAssignments} ${_where}`;\n    return this._client.execute<ResultSetHeader>(query, Object.values(values));\n  }\n\n  delete(where?: WhereClause<TType, TDatabaseType, any, any>) {\n    if (!where) return this.truncate();\n    const _where = new QueryBuilder(this.databaseName, this.name).buildWhereClause(where);\n    const query = `DELETE FROM ${this._path} ${_where}`;\n    return this._client.execute<ResultSetHeader>(query);\n  }\n\n  async vectorSearch<\n    TJoinClauseAs extends string,\n    TJoinClauses extends JoinClause<TType, TDatabaseType, TJoinClauseAs>[],\n    TSelectClause extends SelectClause<TType, TDatabaseType, TJoinClauseAs, TJoinClauses>,\n    TParams extends {\n      prompt: string;\n      vectorColumn: TableColumnName<TType>;\n      embeddingParams?: TAI extends AnyAI ? Parameters<TAI[\"embeddings\"][\"create\"]>[1] : never;\n    },\n  >(params: TParams, queryParams?: QueryBuilderParams<TType, TDatabaseType, TJoinClauseAs, TJoinClauses, TSelectClause>) {\n    type SelectedColumn = ExtractSelectedQueryColumns<TType, TDatabaseType, TJoinClauseAs, TJoinClauses, TSelectClause>;\n    type ResultColumn = SelectedColumn & { [K in VectorScoreKey]: number };\n\n    const clauses = new QueryBuilder<TType, TDatabaseType>(this.databaseName, this.name).buildClauses(queryParams);\n    const promptEmbedding = (await this.ai.embeddings.create(params.prompt, params.embeddingParams))[0] || [];\n    let orderByClause = `ORDER BY ${this.vScoreKey} DESC`;\n\n    if (clauses.orderBy) {\n      orderByClause += clauses.orderBy.replace(/^ORDER BY /, \", \");\n    }\n\n    const query = `\\\n      SET @promptEmbedding = '${JSON.stringify(promptEmbedding)}' :> vector(${promptEmbedding.length}) :> blob;\n      ${[clauses.select, `${params.vectorColumn} <*> @promptEmbedding AS ${this.vScoreKey}`].join(\", \")}\n      FROM ${this._path}\n      ${[clauses.where, clauses.groupBy, orderByClause, clauses.limit, clauses.offset].join(\" \")}\n    `;\n\n    const [rows] = await this._client.execute<[any, (ResultColumn & RowDataPacket)[]]>(query);\n    return rows[1] as ResultColumn[];\n  }\n\n  async createChatCompletion<\n    TJoinClauseAs extends string,\n    TJoinClauses extends JoinClause<TType, TDatabaseType, TJoinClauseAs>[],\n    TSelectClause extends SelectClause<TType, TDatabaseType, TJoinClauseAs, TJoinClauses>,\n    TParams extends Parameters<this[\"vectorSearch\"]>[0] &\n      (TAI extends AnyAI ? Parameters<TAI[\"chatCompletions\"][\"create\"]>[0] : never) & { template?: string },\n  >(\n    params: TParams,\n    queryParams?: QueryBuilderParams<TType, TDatabaseType, TJoinClauseAs, TJoinClauses, TSelectClause>,\n  ): Promise<CreateChatCompletionResult<TParams[\"stream\"]>> {\n    const { prompt, systemRole, template, vectorColumn, embeddingParams, ...createChatCompletionParams } = params;\n\n    const _systemRole =\n      systemRole ??\n      `\\\n      You are a helpful assistant.\\\n      Answer the user's question based on the context provided.\\\n      If the context provided doesn't answer the question asked don't answer the user's question.\\\n      `;\n\n    const _template = template ?? `The user asked: <question>\\nThe most similar context: <context>`;\n    const context = prompt ? await this.vectorSearch({ prompt, vectorColumn, embeddingParams }, queryParams) : \"\";\n    const _prompt = _template.replace(\"<question>\", prompt).replace(\"<context>\", JSON.stringify(context));\n    return (await this.ai.chatCompletions.create({\n      ...createChatCompletionParams,\n      prompt: _prompt,\n      systemRole: _systemRole,\n    })) as CreateChatCompletionResult<TParams[\"stream\"]>;\n  }\n}\n","import { ResultSetHeader } from \"mysql2/promise\";\n\nimport type { ConnectionClient } from \"../connection\";\nimport type { DatabaseType, DatabaseTableName } from \"../database\";\nimport type { AnyAI } from \"@singlestore/ai\";\n\nimport { type TableName, type TableType, type CreateTableSchema, Table } from \"./table\";\n\nexport class TableManager<TDatabaseType extends DatabaseType, TAI extends AnyAI | undefined> {\n  constructor(\n    private _client: ConnectionClient,\n    private _ai: TAI,\n    public databaseName: TDatabaseType[\"name\"],\n  ) {}\n\n  static async create<\n    TName extends TableName,\n    TType extends TableType,\n    TDatabaseType extends DatabaseType,\n    TAI extends AnyAI | undefined,\n  >(client: ConnectionClient, databaseName: TDatabaseType[\"name\"], schema: CreateTableSchema<TName, TType>, ai?: TAI) {\n    const clauses = Table.schemaToClauses(schema);\n\n    await client.execute<ResultSetHeader>(`\\\n      CREATE TABLE IF NOT EXISTS ${databaseName}.${schema.name} (${clauses})\n    `);\n\n    return new Table<TName, TType, TDatabaseType, TAI>(client, schema.name as TType[\"name\"], databaseName, ai);\n  }\n\n  use<TName extends DatabaseTableName<TDatabaseType> | (TableName & {}), TType>(name: TName) {\n    return new Table<\n      TName,\n      TType extends TableType\n        ? TType\n        : TName extends DatabaseTableName<TDatabaseType>\n          ? TDatabaseType[\"tables\"][TName]\n          : TableType,\n      TDatabaseType,\n      TAI\n    >(this._client, name as TName, this.databaseName, this._ai);\n  }\n\n  async create<TName extends TableName, TType extends TableType>(schema: CreateTableSchema<TName, TType>) {\n    return TableManager.create<TName, TType, TDatabaseType, TAI>(this._client, this.databaseName, schema, this._ai);\n  }\n\n  async drop(\n    name: DatabaseTableName<TDatabaseType> | (TableName & {}),\n    ...args: Parameters<typeof Table.drop> extends [any, any, any, ...infer Rest] ? Rest : never\n  ) {\n    return Table.drop(this._client, this.databaseName, name, ...args);\n  }\n\n  async truncate(\n    name: DatabaseTableName<TDatabaseType> | (TableName & {}),\n    ...args: Parameters<typeof Table.truncate> extends [any, any, any, ...infer Rest] ? Rest : never\n  ) {\n    return Table.truncate(this._client, this.databaseName, name, ...args);\n  }\n\n  async rename(\n    name: DatabaseTableName<TDatabaseType> | (TableName & {}),\n    ...args: Parameters<typeof Table.rename> extends [any, any, any, ...infer Rest] ? Rest : never\n  ) {\n    return Table.rename(this._client, this.databaseName, name, ...args);\n  }\n}\n","import { ResultSetHeader } from \"mysql2/promise\";\n\nimport type { ConnectionClient } from \"../connection\";\nimport type { WorkspaceSchema } from \"../workspace\";\nimport type { AnyAI } from \"@singlestore/ai\";\n\nimport { type TableType, type CreateTableSchema, TableManager, Table } from \"../table\";\n\nexport type DatabaseName = string;\n\nexport interface DatabaseType {\n  name: DatabaseName;\n  tables: Record<PropertyKey, TableType>;\n}\n\nexport interface DatabaseSchema<TType extends DatabaseType> {\n  name: TType[\"name\"];\n  tables?: {\n    [K in keyof TType[\"tables\"]]: Omit<CreateTableSchema<Extract<K, string>, TType[\"tables\"][K]>, \"name\">;\n  };\n}\n\nexport interface DatabaseInfo<TType extends DatabaseType> {\n  name: TType[\"name\"];\n}\n\nexport interface DatabaseInfoExtended<TType extends DatabaseType> extends DatabaseInfo<TType> {\n  commits: number;\n  role: string;\n  state: string;\n  position: string;\n  details: string;\n  asyncSlaves: number;\n  syncSlaves: string;\n  consensusSlaves: number;\n  committedPosition: string;\n  hardenedPosition: string;\n  replayPosition: string;\n  term: number;\n  lastPageTerm: number;\n  memoryMBs: number;\n  pendingIOs: number;\n  pendingBlobFSyncs: number;\n}\n\nexport type DatabaseTableName<TType extends DatabaseType> = Extract<keyof TType[\"tables\"], string>;\n\nexport type InferDatabaseType<T> = T extends Database<infer TType, any, any> ? TType : never;\n\nexport type DatabaseTablesToRecords<TTables extends DatabaseType[\"tables\"]> = { [K in keyof TTables]: TTables[K][] };\n\nexport type AnyDatabase = Database<any, any, any>;\n\nexport class Database<\n  TType extends DatabaseType,\n  TWorkspaceName extends WorkspaceSchema[\"name\"] | undefined,\n  TAI extends AnyAI | undefined,\n> {\n  table: TableManager<TType, TAI>;\n\n  constructor(\n    private _client: ConnectionClient,\n    private _ai: TAI,\n    public name: TType[\"name\"],\n    public workspaceName: TWorkspaceName,\n  ) {\n    this.table = new TableManager(this._client, this._ai, this.name);\n  }\n\n  static async drop<TName extends DatabaseName>(client: ConnectionClient, name: TName) {\n    return client.execute<ResultSetHeader>(`DROP DATABASE IF EXISTS ${name}`);\n  }\n\n  static normalizeInfo<\n    TType extends DatabaseType,\n    TExtended extends boolean,\n    _ReturnType = TExtended extends true ? DatabaseInfoExtended<TType> : DatabaseInfo<TType>,\n  >(info: any, extended?: TExtended): _ReturnType {\n    const name = info[Object.keys(info).find((key) => key.startsWith(\"Database\")) as string];\n    if (!extended) return { name } as _ReturnType;\n\n    return {\n      name,\n      commits: info.Commits,\n      role: info.Role,\n      state: info.State,\n      position: info.Position,\n      details: info.Details,\n      asyncSlaves: info.AsyncSlaves,\n      syncSlaves: info.SyncSlaves,\n      consensusSlaves: info.ConsensusSlaves,\n      committedPosition: info.CommittedPosition,\n      hardenedPosition: info.HardenedPosition,\n      replayPosition: info.ReplayPosition,\n      term: info.Term,\n      lastPageTerm: info.LastPageTerm,\n      memoryMBs: info[\"Memory (MBs)\"],\n      pendingIOs: info[\"Pending IOs\"],\n      pendingBlobFSyncs: info[\"Pending blob fsyncs\"],\n    } as _ReturnType;\n  }\n\n  async drop(...args: Parameters<typeof Database.drop> extends [any, any, ...infer Rest] ? Rest : never) {\n    return Database.drop(this._client, this.name, ...args);\n  }\n\n  async showInfo<TExtended extends boolean = false>(extended?: TExtended) {\n    const clauses = [\"SHOW DATABASES\"];\n    if (extended) clauses.push(\"EXTENDED\");\n    clauses.push(`LIKE '${this.name}'`);\n    const [rows] = await this._client.query<any[]>(clauses.join(\" \"));\n    return Database.normalizeInfo<TType, TExtended>(rows[0], extended);\n  }\n\n  async showTablesInfo<TExtended extends boolean = false>(extended?: TExtended) {\n    const clauses = [`SHOW TABLES IN ${this.name}`];\n    if (extended) clauses.push(\"EXTENDED\");\n    const [rows] = await this._client.query<any[]>(clauses.join(\" \"));\n    return rows.map((row) => {\n      return Table.normalizeInfo<Extract<keyof TType[\"tables\"], string>, TExtended>(row, extended);\n    });\n  }\n\n  async describe() {\n    const [info, tablesInfo] = await Promise.all([this.showInfo(true), this.showTablesInfo(true)]);\n\n    return {\n      ...info,\n      tables: await Promise.all(\n        tablesInfo.map(async (tableInfo) => {\n          const table = this.table.use(tableInfo.name);\n          return { ...tableInfo, columns: await table.showColumnsInfo() };\n        }),\n      ),\n    };\n  }\n\n  async query<TReturnType extends any[]>(statement: string) {\n    const statements = [`USE ${this.name}`, statement].join(\";\\n\");\n    const [rows] = await this._client.execute<TReturnType>(statements);\n    return rows.slice(1) as TReturnType[];\n  }\n}\n","import { type AnyAI } from \"@singlestore/ai\";\n\nimport type { ConnectionClient } from \"../connection\";\nimport type { WorkspaceSchema } from \"../workspace\";\nimport type { Tail } from \"@repo/utils\";\nimport type { ResultSetHeader } from \"mysql2/promise\";\n\nimport { TableManager } from \"../table\";\n\nimport { type DatabaseType, Database, type DatabaseSchema } from \"./database\";\n\nexport class DatabaseManager<TWorkspaceName extends WorkspaceSchema[\"name\"] | undefined, TAI extends AnyAI | undefined> {\n  constructor(\n    private _client: ConnectionClient,\n    private _ai: TAI,\n    public workspaceName: TWorkspaceName,\n  ) {}\n\n  use<TType extends DatabaseType>(name: TType[\"name\"]) {\n    return new Database<TType, TWorkspaceName, TAI>(this._client, this._ai, name, this.workspaceName);\n  }\n\n  async create<TType extends DatabaseType>(schema: DatabaseSchema<TType>) {\n    const clauses: string[] = [`CREATE DATABASE IF NOT EXISTS ${schema.name}`];\n    if (this.workspaceName) clauses.push(`ON WORKSPACE \\`${this.workspaceName}\\``);\n    await this._client.execute<ResultSetHeader>(clauses.join(\" \"));\n\n    if (schema.tables) {\n      await Promise.all(\n        Object.entries(schema.tables).map(([name, tableSchema]) => {\n          return TableManager.create(this._client, schema.name, { ...tableSchema, name }, this._ai);\n        }),\n      );\n    }\n\n    return new Database<TType, TWorkspaceName, TAI>(this._client, this._ai, schema.name, this.workspaceName);\n  }\n\n  async drop(...args: Tail<Parameters<typeof Database.drop>>) {\n    return Database.drop(this._client, ...args);\n  }\n}\n","import type { WorkspaceSchema } from \"./workspace\";\nimport type { AnyAI } from \"@singlestore/ai\";\n\nimport { Connection, type ConnectionConfig } from \"../connection\";\nimport { DatabaseManager } from \"../database\";\n\nexport interface CreateWorkspaceConnectionConfig<\n  TName extends WorkspaceSchema[\"name\"] | undefined,\n  TAI extends AnyAI | undefined,\n> extends ConnectionConfig {\n  name?: TName;\n  ai?: TAI;\n}\n\nexport class WorkspaceConnection<\n  TName extends WorkspaceSchema[\"name\"] | undefined,\n  TAI extends AnyAI | undefined,\n> extends Connection {\n  public name: TName;\n  private _ai: TAI;\n  database: DatabaseManager<TName, TAI>;\n\n  constructor({ name, ai, ...config }: CreateWorkspaceConnectionConfig<TName, TAI>) {\n    super(config);\n    this.name = name as TName;\n    this._ai = ai as TAI;\n    this.database = new DatabaseManager(this.client, this._ai, this.name);\n  }\n\n  static create<TName extends WorkspaceSchema[\"name\"] | undefined, TAI extends AnyAI | undefined>(\n    config: CreateWorkspaceConnectionConfig<TName, TAI>,\n  ) {\n    return new WorkspaceConnection(config);\n  }\n}\n","import { URLSearchParams } from \"url\";\n\nimport type { PrivateConnectionSchema } from \"../../private-connection\";\nimport type { WorkspaceSchema } from \"../workspace\";\n\nimport { type API, APIManager } from \"../../api\";\n\nexport interface GetWorkspacePrivateConnectionParams<TIsKai extends boolean | undefined> {\n  isKai?: TIsKai;\n}\n\nexport class WorkspacePrivateConnectionManager extends APIManager {\n  protected _baseURL: string;\n\n  constructor(\n    api: API,\n    private _workspaceID: WorkspaceSchema[\"workspaceID\"],\n    private _groupID: WorkspaceSchema[\"workspaceGroupID\"],\n  ) {\n    super(api);\n    this._baseURL = WorkspacePrivateConnectionManager.getBaseURL(this._workspaceID);\n  }\n\n  static getBaseURL(workspaceID: WorkspaceSchema[\"workspaceID\"]) {\n    return `/workspaces/${workspaceID}/privateConnections`;\n  }\n\n  async get<TIsKai extends boolean | undefined = undefined>(params?: GetWorkspacePrivateConnectionParams<TIsKai>) {\n    const searchParams = new URLSearchParams({ workspaceGroupID: this._groupID });\n    return this._execute<TIsKai extends undefined ? PrivateConnectionSchema[] : { serviceName: string }>(\n      `${params?.isKai ? \"/kai\" : \"\"}?${searchParams.toString()}`,\n    );\n  }\n\n  async outbundAllowList() {\n    return this._execute<{ outboundAllowList: string }[]>(\"/outbundAllowList\");\n  }\n}\n","import type { AnyAI } from \"@singlestore/ai\";\n\nimport { APIManager, type API } from \"../api\";\n\nimport { type CreateWorkspaceConnectionConfig, WorkspaceConnection } from \"./connection\";\nimport { WorkspacePrivateConnectionManager } from \"./private-connection\";\n\n// Ref: https://www.singlestore.com/cloud-pricing/\nexport type WorkspaceSize = string;\n\nexport interface WorkspaceResumeAttachmentSchema {\n  attachment: \"READWRITE\" | \"READONLY\";\n  database: string;\n  error: string;\n  success: boolean;\n}\n\nexport interface WorkspaceResumeAttachment extends Omit<WorkspaceResumeAttachmentSchema, \"attachment\"> {\n  type: WorkspaceResumeAttachmentSchema[\"attachment\"];\n}\n\nexport interface WorkspaceAutoSuspendSchema {\n  suspendType: \"IDLE\" | \"SCHEDULED\";\n  idleAfterSeconds: number;\n  idleChangedAt: string | undefined;\n  scheduledChangedAt: string | undefined;\n  scheduledSuspendAt: string | undefined;\n  suspendTypeChangedAt: string | undefined;\n}\n\nexport interface WorkspaceAutoSuspend\n  extends Omit<\n    WorkspaceAutoSuspendSchema,\n    \"idleChangedAt\" | \"scheduledChangedAt\" | \"scheduledSuspendAt\" | \"suspendTypeChangedAt\"\n  > {\n  idleChangedAt: Date | undefined;\n  scheduledChangedAt: Date | undefined;\n  scheduledSuspendAt: Date | undefined;\n  suspendTypeChangedAt: Date | undefined;\n}\n\nexport interface WorkspaceSchema {\n  workspaceID: string;\n  workspaceGroupID: string;\n  name: string;\n  endpoint: string;\n  size: WorkspaceSize;\n  state: \"ACTIVE\" | \"PENDING\" | \"SUSPENDED\" | \"FAILED\" | \"TERMINATED\";\n  scaleFactor: 1 | 2 | 4;\n  scalingProgress: number | undefined;\n  cacheConfig: 1 | 2 | 4;\n  kaiEnabled: boolean;\n  deploymentType: \"PRODUCTION\" | \"NON-PRODUCTION\";\n  createdAt: string;\n  lastResumedAt: string | undefined;\n  terminatedAt: string | undefined;\n  autoSuspend: WorkspaceAutoSuspendSchema | undefined;\n  resumeAttachments: WorkspaceResumeAttachmentSchema[];\n}\n\nexport interface UpdateWorkspaceBody\n  extends Partial<Pick<WorkspaceSchema, \"size\" | \"deploymentType\" | \"cacheConfig\" | \"scaleFactor\">> {\n  enableKai?: boolean;\n  autoSuspend?: {\n    suspendType?: WorkspaceAutoSuspendSchema[\"suspendType\"] | \"DISABLED\";\n    suspendAfterSeconds?: number;\n  };\n}\n\nexport interface ResumeWorkspaceBody {\n  disableAutoSuspend?: boolean;\n}\n\nexport interface ConnectWorkspaceConfig<TName extends WorkspaceSchema[\"name\"] | undefined, TAI extends AnyAI | undefined>\n  extends Omit<CreateWorkspaceConnectionConfig<TName, TAI>, \"name\" | \"host\" | \"ai\"> {}\n\nexport class Workspace<TName extends WorkspaceSchema[\"name\"], TAI extends AnyAI | undefined> extends APIManager {\n  protected _baseURL: string;\n  privateConnection: WorkspacePrivateConnectionManager;\n\n  constructor(\n    api: API,\n    private _ai: TAI,\n    public id: WorkspaceSchema[\"workspaceID\"],\n    public groupID: WorkspaceSchema[\"workspaceGroupID\"],\n    public name: TName,\n    public endpoint: WorkspaceSchema[\"endpoint\"],\n    public size: WorkspaceSchema[\"size\"],\n    public state: WorkspaceSchema[\"state\"],\n    public scaleFactor: WorkspaceSchema[\"scaleFactor\"],\n    public scalingProgress: WorkspaceSchema[\"scalingProgress\"],\n    public cacheConfig: WorkspaceSchema[\"cacheConfig\"],\n    public kaiEnabled: WorkspaceSchema[\"kaiEnabled\"],\n    public deploymentType: WorkspaceSchema[\"deploymentType\"],\n    public createdAt: Date,\n    public lastResumedAt: Date | undefined,\n    public terminatedAt: Date | undefined,\n    public autoSuspend: WorkspaceAutoSuspend | undefined,\n    public resumeAttachments: WorkspaceResumeAttachment[] | undefined,\n  ) {\n    super(api);\n    this._baseURL = Workspace.getBaseURL(this.id);\n    this.privateConnection = new WorkspacePrivateConnectionManager(this._api, this.id, this.groupID);\n  }\n\n  static getBaseURL(id: WorkspaceSchema[\"workspaceID\"]) {\n    return `/workspaces/${id}`;\n  }\n\n  static async update(\n    api: API,\n    id: WorkspaceSchema[\"workspaceID\"],\n    body: UpdateWorkspaceBody,\n  ): Promise<WorkspaceSchema[\"workspaceID\"]> {\n    const response = await api.execute<Pick<WorkspaceSchema, \"workspaceID\">>(this.getBaseURL(id), {\n      method: \"PATCH\",\n      body: JSON.stringify(body),\n    });\n\n    return response.workspaceID;\n  }\n\n  static async delete(api: API, id: WorkspaceSchema[\"workspaceID\"]): Promise<WorkspaceSchema[\"workspaceID\"]> {\n    const response = await api.execute<Pick<WorkspaceSchema, \"workspaceID\">>(this.getBaseURL(id), {\n      method: \"DELETE\",\n    });\n\n    return response.workspaceID;\n  }\n\n  static async resume(\n    api: API,\n    id: WorkspaceSchema[\"workspaceID\"],\n    body: ResumeWorkspaceBody = {},\n  ): Promise<WorkspaceSchema[\"workspaceID\"]> {\n    const response = await api.execute<Pick<WorkspaceSchema, \"workspaceID\">>(`${this.getBaseURL(id)}/resume`, {\n      method: \"POST\",\n      body: JSON.stringify(body),\n    });\n\n    return response.workspaceID;\n  }\n\n  static async suspend(api: API, id: WorkspaceSchema[\"workspaceID\"]): Promise<WorkspaceSchema[\"workspaceID\"]> {\n    const response = await api.execute<Pick<WorkspaceSchema, \"workspaceID\">>(`${this.getBaseURL(id)}/suspend`, {\n      method: \"POST\",\n    });\n\n    return response.workspaceID;\n  }\n\n  static async getState(api: API, id: WorkspaceSchema[\"workspaceID\"]): Promise<WorkspaceSchema[\"state\"]> {\n    const searchParams = new URLSearchParams({ fields: \"state\" });\n    const respone = await api.execute<Pick<WorkspaceSchema, \"state\">>(`${this.getBaseURL(id)}?${searchParams.toString()}`);\n    return respone.state;\n  }\n\n  connect(config: ConnectWorkspaceConfig<TName, TAI>) {\n    return WorkspaceConnection.create({ ...config, name: this.name, ai: this._ai, host: this.endpoint });\n  }\n\n  async update(body: UpdateWorkspaceBody) {\n    return Workspace.update(this._api, this.id, body);\n  }\n\n  async delete() {\n    return Workspace.delete(this._api, this.id);\n  }\n\n  async resume(body?: ResumeWorkspaceBody) {\n    return Workspace.resume(this._api, this.id, body);\n  }\n\n  async suspend() {\n    return Workspace.suspend(this._api, this.id);\n  }\n\n  async getState() {\n    return Workspace.getState(this._api, this.id);\n  }\n}\n","import type { WorkspaceGroupSchema } from \"../workspace-group\";\nimport type { Tail } from \"@repo/utils\";\nimport type { AnyAI } from \"@singlestore/ai\";\n\nimport { APIManager, type API } from \"../api\";\n\nimport { type WorkspaceSchema, type UpdateWorkspaceBody, Workspace } from \"./workspace\";\n\ninterface CreateWorkspaceBody\n  extends Pick<WorkspaceSchema, \"name\">,\n    Partial<Pick<WorkspaceSchema, \"cacheConfig\" | \"scaleFactor\" | \"size\">>,\n    Pick<UpdateWorkspaceBody, \"enableKai\" | \"autoSuspend\"> {}\n\nexport type GetWorkspaceSelectParam = (keyof WorkspaceSchema)[] | undefined;\n\nexport type GetWorkspaceWhereParam = { id: WorkspaceSchema[\"workspaceID\"] } | { name: WorkspaceSchema[\"name\"] } | undefined;\n\nexport interface GetWorkspaceParams<\n  TSelect extends GetWorkspaceSelectParam = undefined,\n  TWhere extends GetWorkspaceWhereParam = undefined,\n> {\n  select?: TSelect;\n  where?: TWhere;\n  includeTerminated?: boolean;\n}\n\ntype WorkspaceBySelect<TSelect extends GetWorkspaceSelectParam> = TSelect extends (keyof Workspace<any, any>)[]\n  ? Pick<Workspace<any, any>, TSelect[number]>\n  : Workspace<any, any>;\n\nexport class WorkspaceManager<TAI extends AnyAI | undefined> extends APIManager {\n  protected _baseURL: string = \"/workspaces\";\n\n  constructor(\n    api: API,\n    private _ai: TAI,\n    private _workspaceGroupID: WorkspaceGroupSchema[\"workspaceGroupID\"],\n  ) {\n    super(api);\n  }\n\n  private _create(data: WorkspaceSchema) {\n    return new Workspace(\n      this._api,\n      this._ai,\n      data.workspaceID,\n      data.workspaceGroupID,\n      data.name,\n      data.endpoint,\n      data.size,\n      data.state,\n      data.scaleFactor,\n      data.scalingProgress,\n      data.cacheConfig,\n      data.kaiEnabled,\n      data.deploymentType,\n      new Date(data.createdAt),\n      data.lastResumedAt ? new Date(data.lastResumedAt) : undefined,\n      data.terminatedAt ? new Date(data.terminatedAt) : undefined,\n      data.autoSuspend\n        ? {\n            ...data.autoSuspend,\n            idleChangedAt: data.autoSuspend.idleChangedAt ? new Date(data.autoSuspend.idleChangedAt) : undefined,\n            scheduledChangedAt: data.autoSuspend.scheduledChangedAt ? new Date(data.autoSuspend.scheduledChangedAt) : undefined,\n            scheduledSuspendAt: data.autoSuspend.scheduledSuspendAt ? new Date(data.autoSuspend.scheduledSuspendAt) : undefined,\n            suspendTypeChangedAt: data.autoSuspend.suspendTypeChangedAt\n              ? new Date(data.autoSuspend.suspendTypeChangedAt)\n              : undefined,\n          }\n        : undefined,\n      data.resumeAttachments?.map(({ attachment: type, ...attachment }) => ({ ...attachment, type })),\n    );\n  }\n\n  async create(body: CreateWorkspaceBody) {\n    const response = await this._execute<Pick<WorkspaceSchema, \"workspaceID\">>(\"\", {\n      method: \"POST\",\n      body: JSON.stringify({ ...body, workspaceGroupID: this._workspaceGroupID }),\n    });\n\n    if (typeof response === \"string\") {\n      throw new Error(response);\n    }\n\n    return this.get({ where: { id: response.workspaceID } });\n  }\n\n  async get<\n    TSelect extends GetWorkspaceSelectParam = undefined,\n    TWhere extends GetWorkspaceWhereParam = undefined,\n    _TReturnType = TWhere extends { id: WorkspaceSchema[\"workspaceID\"] }\n      ? WorkspaceBySelect<TSelect> | undefined\n      : WorkspaceBySelect<TSelect>[],\n  >({ where, select, includeTerminated }: GetWorkspaceParams<TSelect, TWhere> = {}): Promise<_TReturnType> {\n    let url = \"\";\n\n    const searchParams = new URLSearchParams({\n      workspaceGroupID: this._workspaceGroupID,\n      includeTerminated: includeTerminated ? String(includeTerminated) : String(false),\n    });\n\n    if (where) {\n      if (\"id\" in where) {\n        url = `${url}/${where.id}`;\n      }\n    }\n\n    if (select?.length) {\n      searchParams.set(\"fields\", select.join(\",\"));\n    }\n\n    const response = await this._execute<TWhere extends undefined ? WorkspaceSchema[] : WorkspaceSchema>(\n      `${url}?${searchParams.toString()}`,\n    );\n\n    if (Array.isArray(response)) {\n      return response\n        .filter((data) => (where && \"name\" in where ? data.name === where.name : true))\n        .map((data) => this._create(data)) as _TReturnType;\n    }\n\n    return this._create(response) as _TReturnType;\n  }\n\n  async update(...args: Tail<Parameters<typeof Workspace.update>>) {\n    return Workspace.update(this._api, ...args);\n  }\n\n  async delete(...args: Tail<Parameters<typeof Workspace.delete>>) {\n    return Workspace.delete(this._api, ...args);\n  }\n\n  async resume(...args: Tail<Parameters<typeof Workspace.resume>>) {\n    return Workspace.resume(this._api, ...args);\n  }\n\n  async suspend(...args: Tail<Parameters<typeof Workspace.suspend>>) {\n    return Workspace.suspend(this._api, ...args);\n  }\n\n  async getState(...args: Tail<Parameters<typeof Workspace.getState>>) {\n    return Workspace.getState(this._api, ...args);\n  }\n}\n","export function getKeyByValue<T extends Record<string, unknown>>(object: T, value: T[keyof T]): keyof T | undefined {\n  for (const key in object) {\n    if (object[key] === value) {\n      return key as keyof T;\n    }\n  }\n\n  return undefined;\n}\n","import type { WorkspaceGroupSchema } from \"../workspace-group\";\n\nimport { type API, APIManager } from \"../../api\";\n\nexport type WorkspaceGroupStageContent = string | any[];\n\nexport interface WorkspaceGroupStageSchema {\n  name: string;\n  content: WorkspaceGroupStageContent;\n  type: \"json\" | \"directory\" | null;\n  path: string;\n  format: string | null;\n  mimetype: string | null;\n  size: number;\n  writable: boolean;\n  created: string;\n  last_modified: string;\n}\n\nexport interface UpdateWorkspaceGroupStageBody {\n  newPath?: WorkspaceGroupStageSchema[\"path\"];\n}\n\nexport class WorkspaceGroupStage extends APIManager {\n  protected _baseURL: string;\n\n  constructor(\n    api: API,\n    private _workspaceGroupID: WorkspaceGroupSchema[\"workspaceGroupID\"],\n    public name: WorkspaceGroupStageSchema[\"name\"],\n    public content: WorkspaceGroupStageSchema[\"content\"],\n    public type: WorkspaceGroupStageSchema[\"type\"],\n    public path: WorkspaceGroupStageSchema[\"path\"],\n    public format: WorkspaceGroupStageSchema[\"format\"],\n    public mimetype: WorkspaceGroupStageSchema[\"mimetype\"],\n    public size: WorkspaceGroupStageSchema[\"size\"],\n    public writable: WorkspaceGroupStageSchema[\"writable\"],\n    public createdAt: Date | undefined,\n    public modifiedAt: Date | undefined,\n  ) {\n    super(api);\n    this._baseURL = WorkspaceGroupStage.getBaseURL(this._workspaceGroupID, this.path);\n  }\n\n  static getBaseURL(workspaceGroupID: WorkspaceGroupSchema[\"workspaceGroupID\"], path: WorkspaceGroupStageSchema[\"path\"]) {\n    return `/stage/${workspaceGroupID}/fs/${path}`;\n  }\n\n  static serializePath(path?: WorkspaceGroupStageSchema[\"path\"]): string {\n    if (!path) return \"\";\n    return `/${encodeURIComponent(path.startsWith(\"/\") ? path.substring(1) : path)}`;\n  }\n\n  static formatPath(id: WorkspaceGroupSchema[\"workspaceGroupID\"], path?: WorkspaceGroupStageSchema[\"path\"]) {\n    return this.getBaseURL(id, this.serializePath(path));\n  }\n\n  static mergePaths(...paths: (string | undefined)[]): string {\n    return paths.filter(Boolean).join(\"\").replaceAll(\"//\", \"/\");\n  }\n\n  static async get(api: API, id: WorkspaceGroupSchema[\"workspaceGroupID\"], path?: WorkspaceGroupStageSchema[\"path\"]) {\n    const response = await api.execute<WorkspaceGroupStageSchema>(this.formatPath(id, path));\n\n    if (!response.path) {\n      throw new Error(`No stage found with the specified path: ${path}`);\n    }\n\n    return new WorkspaceGroupStage(\n      api,\n      id,\n      response.name,\n      response.content,\n      response.type,\n      response.path,\n      response.format,\n      response.mimetype,\n      response.size,\n      response.writable,\n      response.created ? new Date(response.created) : undefined,\n      response.last_modified ? new Date(response.last_modified) : undefined,\n    );\n  }\n\n  static async update(\n    api: API,\n    id: WorkspaceGroupSchema[\"workspaceGroupID\"],\n    path: WorkspaceGroupStageSchema[\"path\"],\n    body: UpdateWorkspaceGroupStageBody,\n  ) {\n    const response = await api.execute<Pick<WorkspaceGroupStage, \"name\" | \"path\">>(this.formatPath(id, path), {\n      method: \"PATCH\",\n      body: JSON.stringify({\n        ...body,\n        newPath: body.newPath || undefined,\n      }),\n    });\n\n    if (typeof response === \"string\") {\n      throw new Error(response);\n    }\n\n    return response;\n  }\n\n  static async delete(api: API, id: WorkspaceGroupSchema[\"workspaceGroupID\"], path: WorkspaceGroupStage[\"path\"]) {\n    const response = await api.execute<Pick<WorkspaceGroupStage, \"name\" | \"path\">>(this.formatPath(id, path), {\n      method: \"DELETE\",\n    });\n\n    if (typeof response === \"string\") {\n      throw new Error(response);\n    }\n\n    return response;\n  }\n\n  static async createFolder(\n    api: API,\n    id: WorkspaceGroupSchema[\"workspaceGroupID\"],\n    path: WorkspaceGroupStage[\"path\"],\n    name: string,\n  ) {\n    const response = await api.execute<Pick<WorkspaceGroupStage, \"name\" | \"path\">>(\n      `${this.formatPath(id, path)}${encodeURIComponent(name)}/`,\n      { method: \"PUT\" },\n    );\n\n    if (typeof response === \"string\") {\n      throw new Error(response);\n    }\n\n    return this.get(api, id, response.path);\n  }\n\n  // TODO: Complete this method\n  static async uploadFile(\n    api: API,\n    id: WorkspaceGroupSchema[\"workspaceGroupID\"],\n    path: WorkspaceGroupStage[\"path\"],\n    file: File,\n  ) {\n    const formData = new FormData();\n    formData.append(\"file\", file);\n\n    const response = await api.execute(`${this.formatPath(id, path)}/${this.serializePath(file.name)}`, {\n      method: \"PUT\",\n      headers: { \"Content-Type\": \"multipart/form-data\" },\n      body: formData,\n    });\n  }\n\n  async get(path?: WorkspaceGroupStage[\"path\"]) {\n    const _path = WorkspaceGroupStage.mergePaths(this.path, path);\n    return WorkspaceGroupStage.get(this._api, this._workspaceGroupID, _path);\n  }\n\n  async update(body: UpdateWorkspaceGroupStageBody, path?: WorkspaceGroupStage[\"path\"]) {\n    const _path = WorkspaceGroupStage.mergePaths(this.path, path);\n    return WorkspaceGroupStage.update(this._api, this._workspaceGroupID, _path, body);\n  }\n\n  async delete(path?: WorkspaceGroupStage[\"path\"]) {\n    const _path = WorkspaceGroupStage.mergePaths(this.path, path);\n    return WorkspaceGroupStage.delete(this._api, this._workspaceGroupID, _path);\n  }\n\n  async createFolder(name: string, path?: WorkspaceGroupStage[\"path\"]) {\n    const _path = WorkspaceGroupStage.mergePaths(this.path, path);\n    return WorkspaceGroupStage.createFolder(this._api, this._workspaceGroupID, _path, name);\n  }\n\n  async uploadFile(file: File, path?: WorkspaceGroupStage[\"path\"]) {\n    const _path = WorkspaceGroupStage.mergePaths(this.path, path);\n    return WorkspaceGroupStage.uploadFile(this._api, this._workspaceGroupID, _path, file);\n  }\n}\n","import type { WorkspaceGroupSchema } from \"../workspace-group\";\n\nimport { type API, APIManager } from \"../../api\";\n\nimport { WorkspaceGroupStage } from \"./stage\";\n\nexport class WorkspaceGroupStageManager extends APIManager {\n  protected _baseURL: string;\n\n  constructor(\n    api: API,\n    private _workspaceGroupID: WorkspaceGroupSchema[\"workspaceGroupID\"],\n  ) {\n    super(api);\n    this._baseURL = WorkspaceGroupStageManager.getBaseURL(this._workspaceGroupID);\n  }\n\n  static getBaseURL(workspaceGroupID: WorkspaceGroupSchema[\"workspaceGroupID\"]) {\n    return `/stage/${workspaceGroupID}/fs`;\n  }\n\n  async get(...args: Parameters<typeof WorkspaceGroupStage.get> extends [any, any, ...infer Rest] ? Rest : never) {\n    return WorkspaceGroupStage.get(this._api, this._workspaceGroupID, ...args);\n  }\n\n  async update(...args: Parameters<typeof WorkspaceGroupStage.update> extends [any, any, ...infer Rest] ? Rest : never) {\n    return WorkspaceGroupStage.update(this._api, this._workspaceGroupID, ...args);\n  }\n\n  async delete(...args: Parameters<typeof WorkspaceGroupStage.delete> extends [any, any, ...infer Rest] ? Rest : never) {\n    return WorkspaceGroupStage.delete(this._api, this._workspaceGroupID, ...args);\n  }\n\n  async createFolder(\n    ...args: Parameters<typeof WorkspaceGroupStage.createFolder> extends [any, any, ...infer Rest] ? Rest : never\n  ) {\n    return WorkspaceGroupStage.createFolder(this._api, this._workspaceGroupID, ...args);\n  }\n}\n","import type { Region, RegionName, RegionSchema } from \"../../region\";\nimport type { WorkspaceGroupSchema } from \"../workspace-group\";\n\nimport { type API, APIManager } from \"../../api\";\n\nexport interface ReplicatedDatabaseSchema {\n  region: RegionName;\n  databaseName: string;\n  duplicationState: \"Pending\" | \"Active\" | \"Inactive\" | \"Error\";\n}\n\nexport interface StorageDRStatusSchema {\n  compute: {\n    storageDRType: \"Failover\" | \"Failback\" | \"PreProvisionStart\" | \"PreProvisionStop\";\n    storageDRState: \"Active\" | \"Completed\" | \"Failed\" | \"Expired\" | \"Canceled\";\n    completedAttachments: number;\n    completedWorkspaces: number;\n    totalAttachments: number;\n    totalWorkspaces: number;\n  };\n  storage: ReplicatedDatabaseSchema[];\n}\n\nexport class WorkspaceGroupStorageManager extends APIManager {\n  protected _baseURL: string;\n\n  constructor(\n    api: API,\n    private _workspaceGroupID: WorkspaceGroupSchema[\"workspaceGroupID\"],\n  ) {\n    super(api);\n    this._baseURL = WorkspaceGroupStorageManager.getBaseURL(this._workspaceGroupID);\n  }\n\n  static getBaseURL(workspaceGroupID: WorkspaceGroupSchema[\"workspaceGroupID\"]) {\n    return `/workspaceGroups/${workspaceGroupID}/storage`;\n  }\n\n  async getStatus() {\n    return this._execute<StorageDRStatusSchema>(\"/DR/status\");\n  }\n\n  async getRegions(): Promise<Region[]> {\n    const response = await this._execute<RegionSchema[]>(\"/DR/regions\");\n    return response.map((data) => ({ id: data.regionID, name: data.region, provider: data.provider }));\n  }\n}\n","import { getKeyByValue } from \"@repo/utils\";\n\nimport type { AnyAI } from \"@singlestore/ai\";\n\nimport { APIManager, type API } from \"../api\";\nimport { OrganizationManager } from \"../organization\";\nimport { PrivateConnection, type PrivateConnectionSchema } from \"../private-connection\";\nimport { WorkspaceManager } from \"../workspace/manager\";\n\nimport { WorkspaceGroupStageManager } from \"./stage\";\nimport { WorkspaceGroupStorageManager } from \"./storage\";\n\nexport interface WorkspaceGroupUpdateWindowSchema {\n  day: number;\n  hour: number;\n}\n\nexport interface WorkspaceGroupUpdateWindow extends Omit<WorkspaceGroupUpdateWindowSchema, \"day\"> {\n  day: \"mo\" | \"tu\" | \"we\" | \"th\" | \"fr\" | \"sa\" | \"su\";\n}\n\nexport interface WorkspaceGroupSchema {\n  workspaceGroupID: string;\n  name: string;\n  regionID: string;\n  state: \"ACTIVE\" | \"PENDING\" | \"FAILED\" | \"TERMINATED\";\n  smartDRStatus: \"ACTIVE\" | \"STANDBY\" | undefined;\n  allowAllTraffic: boolean | undefined;\n  firewallRanges: string[];\n  updateWindow: WorkspaceGroupUpdateWindowSchema;\n  createdAt: string;\n  expiresAt: string | undefined;\n  terminatedAt: string | undefined;\n}\n\nexport interface UpdateWorkspaceGroupBody\n  extends Partial<Pick<WorkspaceGroupSchema, \"name\" | \"allowAllTraffic\" | \"firewallRanges\">> {\n  expiresAt?: Date;\n  adminPassword?: string;\n  updateWindow?: WorkspaceGroupUpdateWindow;\n}\n\nexport const updateWindowDaysMap: Record<number, WorkspaceGroupUpdateWindow[\"day\"]> = {\n  0: \"su\",\n  1: \"mo\",\n  2: \"tu\",\n  3: \"we\",\n  4: \"th\",\n  5: \"fr\",\n  6: \"sa\",\n};\n\nexport class WorkspaceGroup<TAI extends AnyAI | undefined> extends APIManager {\n  protected _baseURL: string;\n  stage: WorkspaceGroupStageManager;\n  storage: WorkspaceGroupStorageManager;\n  workspace: WorkspaceManager<TAI>;\n\n  constructor(\n    api: API,\n    private _ai: TAI,\n    private _organization: OrganizationManager,\n    public id: WorkspaceGroupSchema[\"workspaceGroupID\"],\n    public name: WorkspaceGroupSchema[\"name\"],\n    public regionID: WorkspaceGroupSchema[\"regionID\"],\n    public state: WorkspaceGroupSchema[\"state\"],\n    public smartDRStatus: WorkspaceGroupSchema[\"smartDRStatus\"],\n    public allowAllTraffic: WorkspaceGroupSchema[\"allowAllTraffic\"],\n    public firewallRanges: WorkspaceGroupSchema[\"firewallRanges\"],\n    public updateWindow: WorkspaceGroupUpdateWindow | undefined,\n    public createdAt: Date,\n    public expiresAt: Date | undefined,\n    public terminatedAt: Date | undefined,\n  ) {\n    super(api);\n    this._baseURL = WorkspaceGroup.getBaseURL(this.id);\n    this.stage = new WorkspaceGroupStageManager(this._api, this.id);\n    this.storage = new WorkspaceGroupStorageManager(this._api, this.id);\n    this.workspace = new WorkspaceManager(this._api, this._ai, this.id);\n  }\n\n  static getBaseURL(id: WorkspaceGroupSchema[\"workspaceGroupID\"]) {\n    return `/workspaceGroups/${id}`;\n  }\n\n  static serializeUpdateWindow(updateWindow: WorkspaceGroupUpdateWindow): WorkspaceGroupUpdateWindowSchema {\n    const day = getKeyByValue(updateWindowDaysMap, updateWindow.day);\n    if (!day) {\n      throw new Error(\n        `Day not found with the given name. Please provide a valid day from the following list: ${Object.values(updateWindowDaysMap).join(\", \")}.`,\n      );\n    }\n\n    return { ...updateWindow, day: Number(day) };\n  }\n\n  static async update(\n    api: API,\n    id: WorkspaceGroupSchema[\"workspaceGroupID\"],\n    body: UpdateWorkspaceGroupBody,\n  ): Promise<WorkspaceGroupSchema[\"workspaceGroupID\"]> {\n    const expiresAt = body.expiresAt ? body.expiresAt.toISOString().split(\".\")[0] + \"Z\" : undefined;\n    const updateWindow = body.updateWindow ? WorkspaceGroup.serializeUpdateWindow(body.updateWindow) : undefined;\n    const response = await api.execute<Pick<WorkspaceGroupSchema, \"workspaceGroupID\">>(this.getBaseURL(id), {\n      method: \"PATCH\",\n      body: JSON.stringify({ ...body, expiresAt, updateWindow }),\n    });\n\n    return response.workspaceGroupID;\n  }\n\n  static async delete(\n    api: API,\n    id: WorkspaceGroupSchema[\"workspaceGroupID\"],\n    force?: boolean,\n  ): Promise<WorkspaceGroupSchema[\"workspaceGroupID\"]> {\n    const params = new URLSearchParams({ force: force ? String(force) : String(false) });\n    const response = await api.execute<Pick<WorkspaceGroupSchema, \"workspaceGroupID\">>(\n      `${this.getBaseURL(id)}?${params.toString()}`,\n      { method: \"DELETE\" },\n    );\n\n    return response.workspaceGroupID;\n  }\n\n  async update(...args: Parameters<typeof WorkspaceGroup.update> extends [any, any, ...infer Rest] ? Rest : never) {\n    return WorkspaceGroup.update(this._api, this.id, ...args);\n  }\n\n  async delete(...args: Parameters<typeof WorkspaceGroup.delete> extends [any, any, ...infer Rest] ? Rest : never) {\n    return WorkspaceGroup.delete(this._api, this.id, ...args);\n  }\n\n  async getPrivateConnections(): Promise<PrivateConnection[]> {\n    const response = await this._execute<PrivateConnectionSchema[]>(`/privateConnections`);\n    return response.map((data) => ({\n      ...data,\n      createdAt: new Date(data.createdAt),\n      deletedAt: new Date(data.deletedAt),\n      updatedAt: new Date(data.updatedAt),\n      activeAt: new Date(data.activeAt),\n    }));\n  }\n\n  async getMetrics() {\n    const org = await this._organization.get();\n    return this._api.execute<string>(`/organizations/${org.id}${WorkspaceGroup.getBaseURL(this.id)}/metrics`, {\n      version: 2,\n    });\n  }\n}\n","import type { Tail } from \"@repo/utils\";\nimport type { AnyAI } from \"@singlestore/ai\";\n\nimport { type API, APIManager } from \"../api\";\nimport { OrganizationManager } from \"../organization\";\nimport { type RegionName, RegionManager } from \"../region\";\n\nimport {\n  WorkspaceGroup,\n  type WorkspaceGroupUpdateWindow,\n  type WorkspaceGroupSchema,\n  updateWindowDaysMap,\n} from \"./workspace-group\";\n\nexport interface CreateWorkspaceGroupBody {\n  name: WorkspaceGroupSchema[\"name\"];\n  adminPassword?: string;\n  allowAllTraffic?: boolean;\n  firewallRanges?: string[];\n  regionName: RegionName;\n  updateWindow?: WorkspaceGroupUpdateWindow;\n  dataBucketKMSKeyID?: string;\n  backupBucketKMSKeyID?: string;\n  expiresAt?: Date;\n}\n\nexport type GetWorkspaceGroupSelectParam = (keyof WorkspaceGroupSchema)[] | undefined;\n\nexport type GetWorkspaceGroupWhereParam =\n  | { id: WorkspaceGroupSchema[\"workspaceGroupID\"] }\n  | { name: WorkspaceGroupSchema[\"name\"] }\n  | undefined;\n\nexport interface GetWorkspaceGroupParams<\n  TSelect extends GetWorkspaceGroupSelectParam = undefined,\n  TWhere extends GetWorkspaceGroupWhereParam = undefined,\n> {\n  select?: TSelect;\n  where?: TWhere;\n  includeTerminated?: boolean;\n}\n\ntype WorkspaceGroupBySelect<TSelect extends GetWorkspaceGroupSelectParam> = TSelect extends (keyof WorkspaceGroup<any>)[]\n  ? Pick<WorkspaceGroup<any>, TSelect[number]>\n  : WorkspaceGroup<any>;\n\nexport class WorkspaceGroupManager<TAI extends AnyAI | undefined> extends APIManager {\n  protected _baseURL: string = \"/workspaceGroups\";\n\n  constructor(\n    _api: API,\n    private _ai: TAI,\n    private _organization: OrganizationManager,\n    private _region: RegionManager,\n  ) {\n    super(_api);\n  }\n\n  private _create(data: WorkspaceGroupSchema): WorkspaceGroup<TAI> {\n    return new WorkspaceGroup(\n      this._api,\n      this._ai,\n      this._organization,\n      data.workspaceGroupID,\n      data.name,\n      data.regionID,\n      data.state,\n      data.smartDRStatus,\n      data.allowAllTraffic,\n      data.firewallRanges,\n      data.updateWindow ? { ...data.updateWindow, day: updateWindowDaysMap[data.updateWindow.day]! } : undefined,\n      new Date(data.createdAt),\n      data.expiresAt ? new Date(data.expiresAt) : undefined,\n      data.terminatedAt ? new Date(data.terminatedAt) : undefined,\n    );\n  }\n\n  async create({ regionName, firewallRanges = [], ...body }: CreateWorkspaceGroupBody) {\n    const region = await this._region.get({ name: regionName });\n    if (!region) {\n      throw new Error(\"Region not found with the given name. Please provide a valid region name.\");\n    }\n\n    const updateWindow = body.updateWindow ? WorkspaceGroup.serializeUpdateWindow(body.updateWindow) : undefined;\n\n    const response = await this._execute<\n      Pick<WorkspaceGroupSchema, \"workspaceGroupID\"> & { adminPassword: string | undefined }\n    >(\"\", {\n      method: \"POST\",\n      body: JSON.stringify({ ...body, firewallRanges, updateWindow, regionID: region.id }),\n    });\n\n    const newWorkspaceGroup = await this._execute<WorkspaceGroupSchema>(`/${response.workspaceGroupID}`);\n\n    return {\n      workspaceGroup: this._create(newWorkspaceGroup),\n      adminPassword: body.adminPassword || response.adminPassword,\n    };\n  }\n\n  async get<\n    TSelect extends GetWorkspaceGroupSelectParam = undefined,\n    TWhere extends GetWorkspaceGroupWhereParam = undefined,\n    _TReturnType = TWhere extends { id: WorkspaceGroupSchema[\"workspaceGroupID\"] }\n      ? WorkspaceGroupBySelect<TSelect> | undefined\n      : WorkspaceGroupBySelect<TSelect>[],\n  >({ where, select, includeTerminated }: GetWorkspaceGroupParams<TSelect, TWhere> = {}): Promise<_TReturnType> {\n    let url = \"\";\n\n    const searchParams = new URLSearchParams({\n      includeTerminated: includeTerminated ? String(includeTerminated) : String(false),\n    });\n\n    if (where) {\n      if (\"id\" in where) {\n        url = `${url}/${where.id}`;\n      }\n    }\n\n    if (select?.length) {\n      searchParams.set(\"fields\", select.join(\",\"));\n    }\n\n    const response = await this._execute<TWhere extends undefined ? WorkspaceGroupSchema[] : WorkspaceGroupSchema>(\n      `${url}?${searchParams.toString()}`,\n    );\n\n    if (Array.isArray(response)) {\n      return response\n        .filter((data) => (where && \"name\" in where ? data.name === where.name : true))\n        .map((data) => this._create(data)) as _TReturnType;\n    }\n\n    return this._create(response) as _TReturnType;\n  }\n\n  async update(...args: Tail<Parameters<typeof WorkspaceGroup.update>>) {\n    return WorkspaceGroup.update(this._api, ...args);\n  }\n\n  async delete(...args: Tail<Parameters<typeof WorkspaceGroup.delete>>) {\n    return WorkspaceGroup.delete(this._api, ...args);\n  }\n}\n","import type { AnyAI } from \"@singlestore/ai\";\n\nimport { API } from \"./api\";\nimport { BillingManager } from \"./billing\";\nimport { JobManager } from \"./job\";\nimport { OrganizationManager } from \"./organization\";\nimport { RegionManager } from \"./region\";\nimport { SecretManager } from \"./secret\";\nimport { TeamManager } from \"./team\";\nimport { type CreateWorkspaceConnectionConfig, WorkspaceConnection, type WorkspaceSchema } from \"./workspace\";\nimport { WorkspaceGroupManager } from \"./workspace-group\";\n\nexport interface ClientConfig<TAI extends AnyAI | undefined = undefined> {\n  ai?: TAI;\n  apiKey?: string;\n}\n\nexport interface ConnectionConfig<\n  TName extends WorkspaceSchema[\"name\"] | undefined = undefined,\n  TAI extends AnyAI | undefined = undefined,\n> extends Omit<CreateWorkspaceConnectionConfig<TName, TAI>, \"ai\"> {}\n\nexport class SingleStoreClient<TAI extends AnyAI | undefined = undefined> {\n  private _ai: TAI;\n  private _api: API;\n\n  billing: BillingManager;\n  job: JobManager;\n  organization: OrganizationManager;\n  region: RegionManager;\n  secret: SecretManager;\n  team: TeamManager;\n  workspaceGroup: WorkspaceGroupManager<TAI>;\n\n  constructor(config?: ClientConfig<TAI>) {\n    this._ai = config?.ai as TAI;\n    this._api = new API(config?.apiKey);\n\n    this.billing = new BillingManager(this._api);\n    this.job = new JobManager(this._api);\n    this.organization = new OrganizationManager(this._api);\n    this.region = new RegionManager(this._api);\n    this.secret = new SecretManager(this._api);\n    this.team = new TeamManager(this._api);\n    this.workspaceGroup = new WorkspaceGroupManager(this._api, this._ai, this.organization, this.region);\n  }\n\n  connect<TName extends WorkspaceSchema[\"name\"] | undefined = undefined>(config: ConnectionConfig<TName, TAI>) {\n    return WorkspaceConnection.create({ ...config, ai: this._ai });\n  }\n}\n"],"mappings":"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","names":["import_mysql2","usage","region","schema"]}